% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jam-igraph-plot.R
\name{jam_igraph}
\alias{jam_igraph}
\title{Jam wrapper to plot igraph}
\usage{
jam_igraph(
  x,
  ...,
  xlim = NULL,
  ylim = NULL,
  expand = 0.03,
  rescale = FALSE,
  node_factor = 1,
  node_factor_l = NULL,
  edge_factor = 1,
  edge_factor_l = NULL,
  label_factor = 1,
  label_factor_l = NULL,
  label_fontsize_l = NULL,
  label_dist_factor = 1,
  label_dist_factor_l = 1,
  use_shadowText = FALSE,
  edge_bundling = c("default", "connections", "none", "mark.groups", "nodegroups"),
  bundle_self = FALSE,
  nodegroups = NULL,
  render_nodes = TRUE,
  render_edges = TRUE,
  render_nodelabels = TRUE,
  render_groups = TRUE,
  vectorized_node_shapes = TRUE,
  plot_grid = FALSE,
  plot_function = jam_plot_igraph,
  mark.groups = list(),
  mark.shape = 1/2,
  mark.col = NULL,
  mark.alpha = 0.2,
  mark.border = NULL,
  mark.expand = 8,
  mark.lwd = 2,
  mark.lty = 1,
  mark.smooth = TRUE,
  mark.cex = 1,
  mark.x.nudge = 0,
  mark.y.nudge = 0,
  verbose = FALSE,
  debug = NULL
)
}
\arguments{
\item{x}{\code{igraph} object to be plotted}

\item{...}{additional arguments are passed to \code{igraph::plot.igraph()}}

\item{xlim, ylim}{default x and y axis limits. When either value is \code{NULL}
the range is defined by the layout coordinate ranges, respectively,
then expanded by adding \code{expand} to each side of the range.}

\item{expand}{\code{numeric} value used to expand the x and y axis ranges,
where \code{0.03} expands each size \verb{3\%}.}

\item{rescale}{\code{logical} indicating whether to rescale the layout
coordinates to \code{c(-1, 1)}. When \code{rescale=FALSE} the original
layout coordinates are used as-is without change.}

\item{node_factor}{\code{numeric} value multiplied by \code{igraph::V(x)$size} to adjust
the relative size of all nodes by a common numeric scalar value.}

\item{node_factor_l, label_factor_l, label_dist_factor_l}{\code{list}
of vectors, where the names of the \code{list} are attribute
names, and the names of each vector are attributes values.
These values are applied in addition to \code{node_factor}, \code{label_factor},
\code{label_dist_factor}, respectively.
The vector values are used as scalar multipliers, analogous to
\code{node_factor}. The purpose is to apply scalar values to different
subsets of nodes. For example, consider:
\verb{node_factor_l=list(nodeType=c(Gene=1, Set=2)}. The list name
\code{"nodeType"} says to look at \code{igraph::vertex_attr(x, "nodeType")}.
Nodes with \code{nodeType="Gene"} will use \code{1}, and \code{nodeType="Set"}
will use \code{2} as the scalar value.}

\item{edge_factor}{\code{numeric} value multiplied by \code{igraph::E(x)$width} to adjust
the relative width of all edges by a common numeric scalar value.}

\item{label_factor}{\code{numeric} value multiplied by \code{igraph::V(x)$label.cex}
and \code{igraph::E(x)$label.cex} to adjust the relative size of all labels on
nodes and edges by a common numeric scalar value.}

\item{label_dist_factor}{\code{numeric} value multiplied by \code{igraph::V(x)$label.dist}
to adjust the relative distance of all nodes labels from the node center
by a common numeric scalar value.}

\item{use_shadowText}{\code{logical} indicating whether to use
\code{jamba::shadowText()} instead of \code{graphics::text()}, in order
to render text labels with a subtle shadow-like outline around
each label. This change improves legibility of labels at
the expense of slightly longer plot rendering time.}

\item{edge_bundling}{\code{character} string or \code{function}, where:
\itemize{
\item \code{"default"} will try to detect an appropriate method: when
\code{nodegroups} or \code{mark.groups} are defined, it chooses the matching
option (see below); otherwise it chooses \code{"connections"}.
\item \code{"none"} will perform no edge bundling. This method is best when
rendering straight edges, or for rendering multiple identical edges
with curvature as defined by \code{igraph::igraph.plotting()}.
\item \code{"connections"} will perform graph edge bundling by
shared connections by calling \code{edge_bundle_bipartite()} then
\code{edge_bundle_nodegroups()}. This option is particularly good
for bipartite graphs such as concept networks (cnet plots).
\item \code{"mark.groups"} will perform graph edge bundling
using \code{mark.groups} by calling \code{edge_bundle_nodegroups()}.
This option is equivalent to \code{"nodegroups"} except that it
uses \code{mark.groups} to define node groupings.
\item \code{"nodegroups"} will perform graph edge bundling
using \code{nodegroups} by calling \code{edge_bundle_nodegroups()}.
This option is equivalent to \code{"mark.groups"} except that it
uses \code{nodegroups} to define node groupings.
\item \code{function} will call a custom edge bundling function using
the \code{igraph} object \code{x} and the igraph parameters \code{param}
as input. This output is currently untested, and is intended
to enable alternative edge bundling functions which may exist
outside this package. The custom function should be able
to use the node layout coordinates in \code{graph_attr(x, "layout")},
and render edges between nodes.
}}

\item{nodegroups}{\code{list} object as output by \code{edge_bundle_bipartite()}
where each list element is a \code{character} vector of vertex node
names present in \code{igraph::V(x)$name}. If no \code{"name"} vertex node
attribute exists, then integer index values are used as names.
Note that all vertex nodes must be represented in \code{nodegroup}
in order for the corresponding edges to be plotted.}

\item{render_nodes, render_edges}{\code{logical} indicating whether to
render vertex nodes, or edges, respectively. Sometimes it can
be useful to call this function for other byproduct outputs,
for example, \code{jam_plot_igraph(graph, add=FALSE, render_nodes=FALSE, render_edges=FALSE)}
will create a new plot device with appropriate axis ranges,
and can be used to render edge bundling results for example.}

\item{render_nodelabels}{\code{logical} indicating whether to draw node
labels, which is typically the last operation in the plot sequence.
Note that node labels can be rendered without also rendering
the nodes or edges.}

\item{render_groups}{\code{logical} indicating whether to render groups
when \code{mark.groups} is supplied. Groups are rendered with a
shaded polygon and border.}

\item{vectorized_node_shapes}{\code{logical} indicating whether to plot
vertex node shapes using vectorized operations. It is substantially
faster, however the one drawback is that nodes are plotted in
order of their shape, which affects the positioning of nodes
when there are node overlaps. This tradeoff is relatively minor,
and it is recommended either to reposition nodes to reduce or
prevent overlaps, or adjust node sizes to reduce overlaps.}

\item{plot_grid}{\code{logical} indicating whether to plot a background grid
indicating units of 2\% across the layout of the network graph. The
units are calculated consistent with \code{nudge_igraph_nodes()},
\code{adjust_cnet_nodeset()} and other functions, scaled relative to the
maximum x- or y-coordinate range of layout of the graph. Layout
is obtained by \code{get_igraph_layout()} which by default uses
supplied \code{layout}, or graph attribute \code{igraph::graph_attr(x, "layout")}.
Note that by default, \code{jam_igraph()} represents the layout with
aspect ratio = 1, so x-coordinates and y-coordiantes are represented
with the same spacing per unit.
This function calls \code{plot_layout_scale()} to render the grid lines.}

\item{plot_function}{\code{function} that renders the graph, not intended to
be changed except for very customized uses. By default
\code{plot_function=jam_plot_igraph()} which calls a modified variant of
\code{igraph:::plot.igraph()}.}

\item{mark.groups}{A list of vertex id vectors. It is interpreted as a set
of vertex groups. Each vertex group is highlighted, by plotting a colored
smoothed polygon around and \dQuote{under} it. See the arguments below to
control the look of the polygons.}

\item{mark.shape}{A numeric scalar or vector. Controls the smoothness of the
vertex group marking polygons. This is basically the \sQuote{shape}
parameter of the \code{\link[graphics:xspline]{graphics::xspline()}} function, its possible
values are between -1 and 1. If it is a vector, then a different value is
used for the different vertex groups.}

\item{mark.col}{A scalar or vector giving the colors of marking the
polygons, in any format accepted by \code{\link[graphics:xspline]{graphics::xspline()}}; e.g.
numeric color ids, symbolic color names, or colors in RGB.}

\item{mark.alpha}{\code{numeric} value between 0 (transparent) and 1 (opaque)
indicating the transparency of \code{mark.col} color fill values,
used only when \code{mark.groups} is defined, and \code{mark.col} is not defined.}

\item{mark.border}{A scalar or vector giving the colors of the borders of
the vertex group marking polygons. If it is \code{NA}, then no border is
drawn.}

\item{mark.expand}{A numeric scalar or vector, the size of the border around
the marked vertex groups. It is in the same units as the vertex sizes. If a
vector is given, then different values are used for the different vertex
groups.}

\item{mark.lwd, mark.lty}{line with and line type parameters for each
\code{mark.groups} polygon.}

\item{mark.cex}{\code{numeric} adjustment for mark label font size, used
when \code{mark.groups} is supplied and has \code{names(mark.groups)}.}

\item{mark.x.nudge, mark.y.nudge}{\code{numeric} values in units of the
maximum x-axis or y-axis range for the layout coordinates,
used to adjust each label displayed when \code{names(mark.groups)}
is defined. These arguments are passed to \code{make_point_hull()}
as \code{label.x.nudge}, \code{label.y.nudge}, respectively.}

\item{verbose}{\code{logical} indicating whether to print verbose output.}

\item{debug}{\code{logical} or \code{character} vector of attributes for
which debug output will be plotted onscreen.}
}
\description{
Jam wrapper to plot igraph
}
\details{
This function is a drop-in replacement of \code{igraph::plot.igraph()},
intended to provide substantially faster vectorized plotting,
to render bundled edges when requested, and
to handle \code{rescale=FALSE} without requiring further adjustments.
Note that this function focuses on recognizing graph options and
settings, then passes the work off to \code{jam_plot_igraph()}
which performs the heavy work of rendering the graph.

It also provides some convenient methods to adjust node
size, label font size, and label distance from node center,
based upon node attributes.
\subsection{vectorized plots}{

This function calls \code{jam_plot_igraph()} as a replacement for
\code{igraph::plot.igraph()}, and that function implements vectorized
plot features when \code{vectorized_node_shapes=TRUE} by default:
\enumerate{
\item When there are multiple different vertex \code{"shape"} attributes,
this function renders nodes vectorized, one shape at a time.
In this scenario, the original \code{igraph::plot.igraph()} draws
each individual vertex,
which is substantially slower (minutes compared to 1-2 seconds)
for large \code{igraph} objects.
\item When there are multiple font families, labels are rendered in
groups by font family, in order to comply with limitations
in \code{graphics::text()}. This situation is fairly rare, however
the speed improvement is substantial, again roughly minutes down
to 1-2 seconds. The \code{igraph::plot.igraph()} renders each node label
individually when there are multiple font families.
}
}

\subsection{rescale=FALSE}{

The default \code{igraph::plot.igraph()} uses \code{rescale=TRUE}, which
can distort the layout coordinates to fit within a fixed
x- and y-axis range \code{c(-1, 1)}. When using \code{rescale=FALSE} the
\code{xlim} and \code{ylim} values are not adjusted to the actual coordinate
range. The desired effect from this function \code{jam_igraph()} is
to apply \code{aspect=1} (\code{asp=1}) which fixes the aspect ratio so
the coordinates represent visual Euclidean distance between nodes,
and to define \code{xlim} and \code{ylim} to accomodate the full layout.
This function also adjusts node \code{vertex.size} and \code{vertex.label.dist}
proportionally.
}

\subsection{edge bundling}{

When \code{edge_bundling} is something other than \code{edge_bundling="none"},
edge connections between nodes are rendered using a specific
function by drawing curved splines for each bundle of edges.
The approach in \code{igraph::plot.igraph()} only draws
straight edges between nodes. The recommended method is
\code{edge_bundling="default"} which will try to detect an appropriate
method to bundle edges. When \code{mark.groups} and \code{nodegroups} are not
defined, the default method is \code{"connections"} which bundles edges
only among nodes that share the same connections. The assumption is
that nodes that share the same connections usually have very similar
layout coordinates, so edge bundling is usually intuitive. In fact,
for a very large set of nodes, they are often in a round cluster
}

\subsection{Adjust node size, label size, label distance}{

The following arguments apply scaling to all nodes or edges:
\itemize{
\item \code{node_factor} - \code{numeric} multiplied by node size
\item \code{edge_factor} - \code{numeric} multiplied by edge size
\item \code{label_factor} - \code{numeric} multiplied by label font size
\item \code{label_dist_factor} - \code{numeric} multiplied by label distance from
node center
}

New attributes \code{vertex.label.fontsize} and \code{edge.label.fontsize}
which define fixed fontsize in points for nodes and edges, respectively.
These values are not modified by \code{vertex.label.cex} nor \code{edge.label.cex}
and are intended to allow control over specific fonts used in the final
figure. Note their calculations are based upon \code{par("ps")} which should
represent device-dependent point size. If this value is inappropriate,
it should be adjusted to control the font sizing.

The following arguments apply scale factor based upon node attribute:
\itemize{
\item \code{node_factor_l} - \code{list} of named vectors applied to node size
\item \code{label_factor_l} - \code{list} of named vectors applied as \code{label_factor}
.   as a multiplier to label font size.
\item \code{label_fontsize_l} - \code{list} of named vectors applied to define a
specific, fixed label fontsize in points, which is not modified
.   by \code{vertex.label.cex} nor \code{label_factor}.
\item \code{label_dist_factor_l} - \code{list} of named vectors applied to label
distance from node center
}

The \code{factor_l} technique is as follows:

\if{html}{\out{<div class="sourceCode R">}}\preformatted{node_factor_l = list(node_attr_name = c(
   attr_value1 = factor1,
   attr_value2 = factor2))
}\if{html}{\out{</div>}}

A specific example:

\if{html}{\out{<div class="sourceCode R">}}\preformatted{node_factor_l = list(nodeType = c(
   Gene=1.5,
   Set=2))
}\if{html}{\out{</div>}}

In this case, nodes with attribute
\code{igraph::V(g)$nodeType == "Gene"} will use factor \code{1.5}
Nodes with attribute
\code{igraph::V(g)$nodeType == "Set"} will use factor \code{2}
All other nodes will not be adjusted.
}

\subsection{Other features}{

The plot layout by default is \strong{not} rescaled to \code{c(-1, 1)}, therefore
allowing direct control over plot dimensions and node sizes.
The plot aspect ratio is fixed at 1, which renders many network layouts
in their intended form, as opposed to scaling each axis to \code{c(-1, 1)},
which can impose distortion of intended layout node distances.

When \code{use_shadowText=TRUE} node labels call \code{jamba::shadowText()}
which draws a small partly transparent outline around labels, making
them more legible when they overlap colored nodes. This step
effectively draws each label \code{n} times, which can slightly slow
the rendering of the overall figure.

When \code{pie_to_jampie=TRUE}, any nodes with \code{shape="pie"} are
changed to \code{shape="jampie"} for the purpose of rendering pie
shapes in vectorized fashion, instead of being drawn for each
node separately. This change is a substantial improvement in
rendering time. In addition, optional node attributes are available:
\itemize{
\item \code{pie.border} to control individual pie wedge borders, which are
drawn as inner borders so each pie wedge border is visible without
\item \code{pie.lwd} to control line width of pie wedge borders.
\item \code{pie.lty} to control the line type of pie wedge borders
\item \code{frame.color} to control the frame border color drawn around the
full circular pie node. This border is drawn as an outer border, so
it will not overlap any internal pie wedge border colors.
}

Default colors for marked node groups \code{mark.col} and \code{mark.border}
when not defined upfront, will call \code{colorjam::rainbowJam()}
and not \code{grDevices::rainbow()}. The \code{colorjam::rainbowJam()}
produces more visually distinct categorical colors.
This behavior can be controlled by supplying a \code{character}
vector with specific colors for \code{mark.col} and \code{mark.border}. Note
that the border should match the colors, or it can be set to \code{"grey45"}
for a generally visible border.

When \code{names(mark.groups)} is defined, the values are used as
labels, positioned at the outer edge of each polygon. The label
text size is adjusted with \code{label.cex}, and the position can
be adjusted with \code{mark.x.nudge}, \code{mark.y.nudge}, in units of
fraction of the maximum x- or y-axis range (effectively fraction
of the layout size).

Optional argument \code{nodegroups} can be supplied, which is a \code{list}
of vectors, where each vector represents a group of nodes. The
\code{nodegroups} can be used with \code{edge_bundling="nodegroups"} to
define custom edge bundling. This option is useful for defining a
group of nodes for edge bundling, when those nodes should not be used
to render group borders as with \code{mark.groups}.

Finally, individual plot components can be individually disabled:
\itemize{
\item \code{render_nodes=FALSE}
\item \code{render_edges=FALSE}
\item \code{render_groups=FALSE}
\item \code{render_nodelabels=FALSE}
}
}
}
\examples{
# Example with karate
karate <- igraph::make_graph("Zachary");
cl <- igraph::cluster_louvain(karate);
jam_igraph(karate,
   layout=layout_with_qfrf(repulse=3.5),
   mark.groups=cl,
  mark.lwd=c(1:4),
  mark.lty=1:4, mark.shape=1,
  edge_bundling="default")

# create example cnet data
cnet <- make_cnet_test(num_sets=3)

## example showing how to use the list form
## This form resizes nodes where igraph::V(g)$nodeType \%in\% "Gene" by 2x,
## and resizes nodes where igraph::V(g)$nodeType \%in\% "Set" by 3x.
node_factor_l <- list(nodeType=c(Gene=1.2, Set=2));

## This form multiplies label.dist for nodeType="Gene" nodes by 1,
## and multiplies label.dist for nodeType="Set" nodes by 0.5
label_dist_factor_l <- list(nodeType=c(Gene=1, Set=0.5))

par("mar"=c(0, 0, 0, 0) + 0.5);
jam_igraph(cnet,
   use_shadowText=TRUE,
   node_factor_l=node_factor_l,
   label_factor=0.6,
   label_factor_l=list(nodeType=c(Gene=1, Set=2)))
par("mar"=c(2, 2, 2, 2));

# Example using edge bundling by community detection
g <- igraph::make_graph("Zachary");
gcom <- igraph::cluster_leading_eigen(g);

jam_igraph(g,
   layout=layout_with_qfr,
   edge_bundling="nodegroups",
   mark.groups=gcom,
   nodegroups=gcom,
   vertex.color=colorjam::group2colors(gcom$membership))

cfuncs <- list(cluster_leading_eigen=igraph::cluster_leading_eigen,
   cluster_edge_betweenness=igraph::cluster_edge_betweenness,
   cluster_fast_greedy=igraph::cluster_fast_greedy,
   cluster_spinglass=igraph::cluster_spinglass)
for (i in seq_along(cfuncs)) {
   cfunc <- cfuncs[[i]];
   gcom <- cfunc(g);
   igraph::V(g)$color <- colorjam::group2colors(gcom$membership);
   g <- color_edges_by_nodes(g);
   set.seed(123);
   jam_igraph(g,
      layout=layout_with_qfr,
      edge_bundling="nodegroups",
      nodegroups=gcom,
      mark.groups=gcom)
   title(main=names(cfuncs)[i]);
}

# fancy example showing mark.groups and colorizing
# edges using node colors
gcom <- igraph::cluster_spinglass(g);
igraph::V(g)$color <- colorjam::group2colors(gcom$membership);
g <- color_edges_by_nodes(g);
jam_igraph(g,
   layout=layout_with_qfrf(repulse=3.2),
   edge_bundling="nodegroups",
   nodegroups=gcom,
   mark.groups=gcom)
title(main=paste0("cluster_spinglass()\n",
   "edge_bundling='nodegroups'"))

# same but different edge_style
jam_igraph(g,
   layout=layout_with_qfrf(repulse=3.2),
   edge_bundling="nodegroups",
   nodegroups=gcom,
   mark.groups=gcom,
   bundle_style="xspline",
   detail=14)
title(main="bundle_style='xspline'")

# same but using node connections
jam_igraph(g,
   layout=layout_with_qfrf(repulse=3.2),
   edge_bundling="connections",
   nodegroups=gcom,
   mark.groups=gcom)
title(main="edge_bundling='connections'")

}
\seealso{
Other jam igraph functions: 
\code{\link{cnet2df}()},
\code{\link{cnet2im}()},
\code{\link{cnetplotJam}()},
\code{\link{cnetplot_internalJam}()},
\code{\link{color_edges_by_nodegroups}()},
\code{\link{color_edges_by_nodes_deprecated}()},
\code{\link{color_edges_by_nodes}()},
\code{\link{color_nodes_by_nodegroups}()},
\code{\link{communities2nodegroups}()},
\code{\link{drawEllipse}()},
\code{\link{edge_bundle_bipartite}()},
\code{\link{edge_bundle_nodegroups}()},
\code{\link{enrichMapJam}()},
\code{\link{fixSetLabels}()},
\code{\link{flip_edges}()},
\code{\link{get_bipartite_nodeset}()},
\code{\link{igraph2pieGraph}()},
\code{\link{jam_plot_igraph}()},
\code{\link{label_communities}()},
\code{\link{layout_with_qfrf}()},
\code{\link{layout_with_qfr}()},
\code{\link{mem2emap}()},
\code{\link{memIM2cnet}()},
\code{\link{mem_multienrichplot}()},
\code{\link{nodegroups2communities}()},
\code{\link{rectifyPiegraph}()},
\code{\link{relayout_with_qfr}()},
\code{\link{removeIgraphBlanks}()},
\code{\link{removeIgraphSinglets}()},
\code{\link{reorderIgraphNodes}()},
\code{\link{rotate_igraph_layout}()},
\code{\link{spread_igraph_labels}()},
\code{\link{subgraph_jam}()},
\code{\link{subsetCnetIgraph}()},
\code{\link{subset_igraph_components}()},
\code{\link{sync_igraph_communities}()},
\code{\link{with_qfr}()}

Other jam plot functions: 
\code{\link{adjust_polygon_border}()},
\code{\link{grid_with_title}()},
\code{\link{mem_enrichment_heatmap}()},
\code{\link{mem_gene_path_heatmap}()},
\code{\link{mem_legend}()},
\code{\link{mem_multienrichplot}()},
\code{\link{mem_plot_folio}()},
\code{\link{plot_layout_scale}()}
}
\concept{jam igraph functions}
\concept{jam plot functions}
