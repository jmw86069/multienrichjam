% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jamenrich-bivariatecolor.R
\name{cell_fun_bivariate}
\alias{cell_fun_bivariate}
\title{ComplexHeatmap cell function with bivariant color}
\usage{
cell_fun_bivariate(
  m,
  prefix = "",
  suffix = "",
  cex = 1,
  col_hm,
  outline = FALSE,
  outline_style = c("none", "contrast", "lighter", "darker", "black", "same"),
  abbrev = FALSE,
  show = NULL,
  rot = 0,
  sep = "\\n",
  mcolor = NULL,
  pch = NULL,
  size_fun = NULL,
  size_by = 1,
  grid_color = "grey80",
  type = c("bivariate", "univariate"),
  verbose = FALSE,
  ...
)
}
\arguments{
\item{m}{\code{list} of 2 or more \code{matrix} objects. The first two
\code{matrix} objects are used for the bivariate color.}

\item{prefix, suffix}{\code{character} vectors that define a prefix and
suffix for each value in \code{m} for each cell.}

\item{cex}{\code{numeric} adjustment for the fontsize used for each label}

\item{col_hm}{\code{function} whose first two arguments accept \code{numeric}
values, and which returns a single color. Note that when \code{mcolor}
is provided, this argument is ignored.}

\item{outline}{\code{logical} indicating whether to draw an outline around
each heatmap cell}

\item{abbrev}{\code{logical} indicating whether numeric values should
be abbreviated using \code{jamba::asSize(..., kiloSize=1000)} which
effectively reduces large numbers to \code{k} for thousands, \code{M} for
millions (M for Mega), \code{G} for billions (G for Giga), etc.}

\item{show}{\code{numeric} indicating which list elements in \code{m} should
be used to formulate a cell label, or \code{NULL} to use no label.}

\item{rot}{\code{numeric} rotation in degrees, to rotate labels inside
each heatmap cell. Mainly useful for heatmaps with extremely tall
cells, use \code{rot=90} for vertical text.}

\item{sep}{\code{character} string used as a separator between multiple
labels inside each cell, used only when \code{show} has more than
one value.}

\item{mcolor}{\code{character} matrix of R colors, with same \code{nrow()}
and \code{ncol()} or each matrix in \code{m}. When \code{mcolor} is supplied,
the colors are used directly, and \code{col_hm} is not used.}

\item{type}{\code{character} string indicating whether the color function
uses bivariate or univariate logic. This argument is intended to
allow this function to be used in both scenarios for consistency.}

\item{...}{additional arguments are passed to \code{col_hm()} to allow
custom options relevant to that function.}
}
\description{
ComplexHeatmap cell function with bivariant color
}
\details{
This function serves as a convenient method to use a
bivariate color scale (biscale) to color heatmap cells.

See:
\itemize{
\item https://kwstat.github.io/pals/
\item https://nowosad.github.io/post/cbc-bp2/
\item https://cran.r-project.org/web/packages/biscale/vignettes/biscale.html
}

This function takes two \code{numeric} data matrices, a color function
that accepts two numeric values as input and returns a color.

This function can also optionally display a text label
inside each heatmap cell, use argument \code{show} to indicate which matrix
or matrices in \code{m} to use for the label.
}
\examples{
set.seed(12);
m <- matrix(rnorm(36)*2.5, ncol=4)
colnames(m) <- LETTERS[1:4]
rownames(m) <- letters[1:4]
m2 <- m;
m2[] <- abs(rnorm(36)*3);
mcolor <- matrix(ncol=3,
   c("white", "white", "white",
   "royalblue4", "gold", "red"),
   byrow=TRUE);
col_bivariate <- colorRamp2D(
   column_breaks=seq(from=-2, to=2, length.out=3),
   row_breaks=seq(from=0, to=5, length.out=2),
   mcolor);
display_colorRamp2D(col_bivariate)

# the heatmap can be created in one step
hm <- ComplexHeatmap::Heatmap(m * m2,
   border=TRUE,
   col=col_bivariate,
   heatmap_legend_param=list(
      color_bar="discrete",
      border=TRUE,
      at=-4:4),
   cell_fun=cell_fun_bivariate(list(m, m2),
      col_hm=col_bivariate,
      prefix=c("-log10P: ", "z-score: "),
      show=2:1),
   show_heatmap_legend=FALSE,
)

lgds <- make_legend_bivariate(col_bivariate,
   ylab="-log10pvalue",
   xlab="z-score");
draw(hm, annotation_legend_list=lgds)

lgds <- make_legend_bivariate(col_bivariate,
   row_breaks=seq(from=0, to=1, by=0.25),
   ylab="-log10pvalue");
draw(hm, annotation_legend_list=lgds)

# heatmap using point circles
ctmax <- 6;
point_size_max <- 12;
point_size_min <- 1;
size_fun_custom <- approxfun(
   x=c(1, ctmax),
   yleft=0,
   ties="ordered",
   yright=point_size_max,
   y=c(1,
      point_size_max));
ct_ticks <- seq(from=0, to=6);
ct_tick_sizes <- size_fun_custom(ct_ticks);

hm2 <- ComplexHeatmap::Heatmap(m * m2,
   border=TRUE,
   col=col_bivariate,
   heatmap_legend_param=list(
      color_bar="discrete",
      border=TRUE,
      at=-4:4),
   cell_fun=cell_fun_bivariate(list(m, m2),
      pch=21,
      size_fun=size_fun_custom,
      size_by=2,
      outline_style="black",
      col_hm=col_bivariate,
      prefix=c("-log10P: ", "z-score: "),
      show=NULL),
   show_heatmap_legend=FALSE,
)
draw(hm2, annotation_legend_list=lgds)

}
