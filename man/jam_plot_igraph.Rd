% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jamenrich-igraph.r
\name{jam_plot_igraph}
\alias{jam_plot_igraph}
\title{Jam igraph vectorized plot function (internal)}
\usage{
jam_plot_igraph(
  x,
  ...,
  axes = FALSE,
  add = FALSE,
  xlim = NULL,
  ylim = NULL,
  mark.groups = list(),
  mark.shape = 1/2,
  mark.col = NULL,
  mark.alpha = 0.2,
  mark.border = NULL,
  mark.expand = 8,
  mark.lwd = 2,
  mark.lty = 1,
  mark.smooth = TRUE,
  pie_to_jampie = TRUE,
  use_shadowText = FALSE,
  vectorized_node_shapes = TRUE,
  edge_bundling = c("default", "connections", "none", "mark.groups", "nodegroups"),
  nodegroups = NULL,
  render_nodes = TRUE,
  render_edges = TRUE,
  render_groups = TRUE,
  render_nodelabels = TRUE,
  params = NULL,
  plot_grid = FALSE,
  verbose = FALSE,
  debug = NULL
)
}
\arguments{
\item{x}{The graph to plot.}

\item{...}{Additional plotting parameters. See \link[igraph]{igraph.plotting} for
the complete list.}

\item{axes}{Logical, whether to plot axes, defaults to FALSE.}

\item{add}{Logical scalar, whether to add the plot to the current device, or
delete the device's current contents first.}

\item{xlim, ylim}{default x and y axis limits. When either value is \code{NULL}
the range is defined by the layout coordinate ranges, respectively,
then expanded by adding \code{expand} to each side of the range.}

\item{mark.groups}{A list of vertex id vectors. It is interpreted as a set
of vertex groups. Each vertex group is highlighted, by plotting a colored
smoothed polygon around and \dQuote{under} it. See the arguments below to
control the look of the polygons.}

\item{mark.shape}{A numeric scalar or vector. Controls the smoothness of the
vertex group marking polygons. This is basically the \sQuote{shape}
parameter of the \code{\link[graphics]{xspline}} function, its possible
values are between -1 and 1. If it is a vector, then a different value is
used for the different vertex groups.}

\item{mark.col}{A scalar or vector giving the colors of marking the
polygons, in any format accepted by \code{\link[graphics]{xspline}}; e.g.
numeric color ids, symbolic color names, or colors in RGB.}

\item{mark.alpha}{\code{numeric} value between 0 (transparent) and 1 (opaque)
indicating the transparency of \code{mark.col} color fill values,
used only when \code{mark.groups} is defined, and \code{mark.col} is not defined.}

\item{mark.border}{A scalar or vector giving the colors of the borders of
the vertex group marking polygons. If it is \code{NA}, then no border is
drawn.}

\item{mark.expand}{A numeric scalar or vector, the size of the border around
the marked vertex groups. It is in the same units as the vertex sizes. If a
vector is given, then different values are used for the different vertex
groups.}

\item{mark.lwd, mark.lty}{line with and line type parameters for each
\code{mark.groups} polygon,}

\item{pie_to_jampie}{\code{logical} indicating whether to convert
vertex shape \code{"pie"} to \code{"jampie"} in order to use vectorized
plotting.}

\item{use_shadowText}{\code{logical} indicating whether to use
\code{jamba::shadowText()} instead of \code{graphics::text()}, in order
to render text labels with a subtle shadow-like outline around
each label. This change improves legibility of labels at
the expense of slightly longer plot rendering time.}

\item{vectorized_node_shapes}{\code{logical} indicating whether to plot
vertex node shapes using vectorized operations. It is substantially
faster, however the one drawback is that nodes are plotted in
order of their shape, which affects the positioning of nodes
when there are node overlaps. This tradeoff is relatively minor,
and it is recommended either to reposition nodes to reduce or
prevent overlaps, or adjust node sizes to reduce overlaps.}

\item{edge_bundling}{\code{character} string or \code{function}, where:
\itemize{
\item \code{"default"} will try to detect an appropriate method: when
\code{nodegroups} or \code{mark.groups} are defined, it chooses the matching
option (see below); otherwise it chooses \code{"connections"}.
\item \code{"none"} will perform no edge bundling. This method is best when
rendering straight edges, or for rendering multiple identical edges
with curvature as defined by \code{igraph::igraph.plotting()}.
\item \code{"connections"} will perform graph edge bundling by
shared connections by calling \code{edge_bundle_bipartite()} then
\code{edge_bundle_nodegroups()}. This option is particularly good
for bipartite graphs such as concept networks (cnet plots).
\item \code{"mark.groups"} will perform graph edge bundling
using \code{mark.groups} by calling \code{edge_bundle_nodegroups()}.
This option is equivalent to \code{"nodegroups"} except that it
uses \code{mark.groups} to define node groupings.
\item \code{"nodegroups"} will perform graph edge bundling
using \code{nodegroups} by calling \code{edge_bundle_nodegroups()}.
This option is equivalent to \code{"mark.groups"} except that it
uses \code{nodegroups} to define node groupings.
\item \code{function} will call a custom edge bundling function using
the \code{igraph} object \code{x} and the igraph parameters \code{param}
as input. This output is currently untested, and is intended
to enable alternative edge bundling functions which may exist
outside this package. The custom function should be able
to use the node layout coordinates in \code{graph_attr(x, "layout")},
and render edges between nodes.
}}

\item{nodegroups}{\code{list} object as output by \code{edge_bundle_bipartite()}
where each list element is a \code{character} vector of vertex node
names present in \code{igraph::V(x)$name}. If no \code{"name"} vertex node
attribute exists, then integer index values are used as names.
Note that all vertex nodes must be represented in \code{nodegroup}
in order for the corresponding edges to be plotted.}

\item{render_nodes, render_edges}{\code{logical} indicating whether to
render vertex nodes, or edges, respectively. Sometimes it can
be useful to call this function for other byproduct outputs,
for example, \code{jam_plot_igraph(graph, add=FALSE, render_nodes=FALSE, render_edges=FALSE)}
will create a new plot device with appropriate axis ranges,
and can be used to render edge bundling results for example.}

\item{render_groups}{\code{logical} indicating whether to render groups
when \code{mark.groups} is supplied. Groups are rendered with a
shaded polygon and border.}

\item{render_nodelabels}{\code{logical} indicating whether to draw node
labels, which is typically the last operation in the plot sequence.
Note that node labels can be rendered without also rendering
the nodes or edges.}

\item{plot_grid}{\code{logical} indicating whether to plot a background grid
indicating units of 2\% across the layout of the network graph. The
units are calculated consistent with \code{nudge_igraph_nodes()},
\code{adjust_cnet_nodeset()} and other functions, scaled relative to the
maximum x- or y-coordinate range of layout of the graph. Layout
is obtained by \code{get_igraph_layout()} which by default uses
supplied \code{layout}, or graph attribute \code{igraph::graph_attr(x, "layout")}.
Note that by default, \code{jam_igraph()} represents the layout with
aspect ratio = 1, so x-coordinates and y-coordiantes are represented
with the same spacing per unit.
This function calls \code{plot_layout_scale()} to render the grid lines.}

\item{verbose}{\code{logical} indicating whether to print verbose output.}

\item{debug}{\code{logical} or \code{character} vector of attributes for
which debug output will be plotted onscreen.}
}
\description{
Jam igraph vectorized plot internal function called by \code{jam_igraph()}
}
\details{
Note that this function is intended to be called by \code{jam_igraph()},
and is an internal function not intended to be called directly.

The \code{jam_igraph()} handles the overall plot equivalent of
\code{igraph::plot.igraph()}, however it calculates layout coordinates,
and defines more useful x- and y-axis ranges, and then
adjusts node and label sizes relevant to the layout data range.
Specifically \code{vertex.size=15} is only useful when the layout range
is rescaled between -1 and 1; however when using \code{jam_igraph()}
the vertex is scaled relative to the actual layout ranges.

The steps here are a reproduction of \code{igraph:::plot.igraph()} with
four changes:
\enumerate{
\item Default \code{rescale=FALSE}, and \code{asp=1} which means igraph layout is
drawn true to the layout coordinates without distortion. To use
default \code{igraph::plot.igraph()} behavior, use \code{rescale=TRUE}.
The new default may not be appropriate for bipartite layout
algorithms that generate two columns, and seems most useful
with organic layouts where aspect ratio 1 helps convey important
meaning in the graph structure, namely by enforcing consistent
x- and y-axis visual distance between nodes.
\itemize{
\item Related: the \code{xlim} and \code{ylim} values are automatically adjusted
to include the layout coordinate range. The default
\code{igraph::plot.igraph(..., rescale=FALSE)} does not adjust the
\code{xlim} and \code{ylim} ranges, which can be problematic when supplying
layout as a function, and therefore the output node coordinates
are not known until the plot rendering step.
}
}

When \code{vectorized_node_shapes=TRUE} by default:
\enumerate{
\item When there are multiple different vertex \code{"shape"} attributes, the
nodes are rendered vectorized one shape at a time. The original
\code{igraph::plot.igraph()} draws each individual vertex one by one,
which is substantially slower (minutes compared to 1-2 seconds)
for large \code{igraph} objects.
\item When there are multiple font families, the default plot function
draws each label one by one. The \code{jam_plot_igraph()} draws
labels in groups of font family, in order to comply with limitations
in \code{graphics::text()}. This situation is fairly rare, however
the speed improvement is substantial, again roughly minutes down
to 1-2 seconds.
}

The fourth difference involves edge bundling:
\enumerate{
\item When \code{edge_bundling} is used, it renders edges differently
than the approach in \code{igraph::plot.igraph()}, by drawing curved
splines for each bundle of edges.
}

Some other distinctive features include:

When \code{use_shadowText=TRUE} node labels call \code{jamba::shadowText()}
which draws a small partly transparent outline around labels, making
them more legible when they overlap colored nodes. This step
effectively draws each label \code{n} times, which can slightly slow
the rendering of the overall figure.

When \code{pie_to_jampie=TRUE}, any nodes with \code{shape="pie"} are
changed to \code{shape="jampie"} for the purpose of rendering pie
shapes in vectorized fashion, instead of being drawn for each
node separately. This change is a substantial improvement in
rendering time.

Default colors for marked node groups \code{mark.col} and \code{mark.border}
when not defined upfront, will call \code{colorjam::rainbowJam()}
and not \verb{grDevices::rainbow(). The }colorjam::rainbowJam()\verb{produces more visually distinct categorical colors. This behavior can be controlled by supplying a}character\verb{vector with specific colors for}mark.col\code{and}mark.border\verb{. Note that the border should match the colors, or it can be set to }"grey45"`
for a generally visible border.

Optional argument \code{nodegroups} can be supplied, which is a \code{list}
of vectors, where each vector represents a group of nodes. The
\code{nodegroups} can be used with \code{edge_bundling="nodegroups"} to
define custom edge bundling.

Finally, individual plot components can be individually disabled:
\itemize{
\item \code{render_nodes=FALSE}
\item \code{render_edges=FALSE}
\item \code{render_groups=FALSE}
\item \code{render_nodelabels=FALSE}
}

Note that this function is not called by default, and is only called
by \code{multienrichjam::jam_igraph()}.

All other arguments are documented in \code{igraph::plot.igraph()}.
}
\seealso{
Other jam igraph functions: 
\code{\link{cnet2df}()},
\code{\link{cnet2im}()},
\code{\link{cnetplotJam}()},
\code{\link{cnetplot_internalJam}()},
\code{\link{color_edges_by_nodes_deprecated}()},
\code{\link{color_edges_by_nodes}()},
\code{\link{drawEllipse}()},
\code{\link{edge_bundle_bipartite}()},
\code{\link{edge_bundle_nodegroups}()},
\code{\link{enrichMapJam}()},
\code{\link{fixSetLabels}()},
\code{\link{flip_edges}()},
\code{\link{get_bipartite_nodeset}()},
\code{\link{igraph2pieGraph}()},
\code{\link{jam_igraph}()},
\code{\link{layout_with_qfrf}()},
\code{\link{layout_with_qfr}()},
\code{\link{memIM2cnet}()},
\code{\link{mem_multienrichplot}()},
\code{\link{rectifyPiegraph}()},
\code{\link{relayout_with_qfr}()},
\code{\link{removeIgraphBlanks}()},
\code{\link{removeIgraphSinglets}()},
\code{\link{reorderIgraphNodes}()},
\code{\link{rotate_igraph_layout}()},
\code{\link{spread_igraph_labels}()},
\code{\link{subgraph_jam}()},
\code{\link{subsetCnetIgraph}()},
\code{\link{subset_igraph_components}()},
\code{\link{with_qfr}()}
}
\concept{jam igraph functions}
