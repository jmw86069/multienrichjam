% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jamgraph-edgebundle.R
\name{edge_bundle_nodegroups}
\alias{edge_bundle_nodegroups}
\title{Bundle edges using node groups}
\usage{
edge_bundle_nodegroups(
  g,
  nodegroups,
  shape = NULL,
  params = NULL,
  midpoint = 0.5,
  detail = 10,
  draw_lines = TRUE,
  nodegroup_midpoints = NULL,
  linear_cor_threshold = 1,
  bundle_style = getOption("jam.bundle_style", "bezier"),
  verbose = FALSE,
  debug = getOption("debug", FALSE),
  ...
)
}
\arguments{
\item{g}{\code{igraph} that contains layout coordinates in
graph attributes, stored as \code{igraph::graph_attr(g, "layout")}.}

\item{nodegroups}{\code{list} of node names, or object with
class \code{"communities"} as produced by \verb{igraph::cluster_*}
methods such as \code{igraph::cluster_walktrap()}. Note that
every node must be represented.}

\item{midpoint}{\code{numeric} vector of one or two values ranging
from \code{0} to \code{1} that define control point positions between
each node group center, used to create each edge spline.}

\item{detail}{\code{integer} number of intermediate points along
the spline to render for each edge.}

\item{draw_lines}{\code{logical} indicating whether to render the edge
splines after calculating them.}

\item{nodegroup_midpoints}{\code{list} with list names that
match \code{names(nodegroups)}. Each \code{list} element contains one or
more x,y coordinates as a \code{numeric} matrix. This option will
define specific coordinates to be used for any entries that
match \code{names(nodegroups)}, and therefore does not use \code{midpoint}
for those nodegroups. Any remaining nodegroups will use the
normal method with \code{midpoint} as described above.}

\item{linear_cor_threshold}{\code{numeric} value between 0 and 1.
Coordinates for each edge, and intermediate control point
coordinates are used in \code{xspline()} to create a curved spline
from node to node. However, when the nodes and intermediate
control points are already linear, the edge will be treated
as a linear edge. To test for linearity, \code{cor()} correlation
is calculated, and values at or above \code{linear_cor_threshold}
are considered linear.

The driving problem is when the control point is colinear with
two nodes, and the control point is positioned outside the two
nodes. Without this modification, the line would appear to pass
from one node beyond the other node, with an arrow (if directed)
pointing back to the other node from the opposite direction.}

\item{verbose}{\code{logical} indicating whether to print verbose output.}

\item{debug}{\code{logical} indicating whether to plot debug output that
may be helpful in understanding the edge bundle control points.}

\item{...}{additional arguments are ignored.}
}
\value{
\code{data.frame} with each edge spline point represented
on its own row, with breaks in edges defined by \code{NA} coordinates.
}
\description{
Bundle edges using node groups
}
\details{
This edge bundling technique relies upon some form of
node grouping, usually derived from network community
detection, or from bipartite nodesets (see
\code{get_bipartite_nodeset()} for details.)

Given a set of node groups, edges are bundled entering
and exiting each node group, along the linear path between
the two node group center positions, using a spline
function and intermediate control points.

The default spline uses the initial node positions, and the
midpoint along the line between the two respective node groups.
The midpoints can be adjusted with the argument \code{midpoint}
and a vector of one or more fractional positions between \code{0} and \code{1}.
A useful alternative is \code{midpoint=c(0.3, 0.7)} which adds
two control points along the linear path between node group
centers, and tends to make the edges bundle closer together
for a longer distance.

When used with bipartite nodesets, edges are bundled between
each nodeset and individual nodes. The edge bundling rules are
the same, with the default \code{midpoint=c(0.4, 0.6)} being centered at half
the distance between the nodeset center, and the single node.
In this case, the \code{midpoint} is directional, always pointing
from the nodeset to the single node, therefore can be adjusted
closer to the nodeset center with \code{midpoint=0.2} or closer to
the single node with \code{midpoint=0.8}.
}
\examples{
# using community detection
karate <- igraph::make_graph("Zachary")
igraph::V(karate)$name <- as.character(seq_len(igraph::vcount(karate)))

# run any igraph::cluster_*()
wc <- igraph::cluster_louvain(karate)
# define list
nodegroups_wc <- split(igraph::V(karate)$name, wc$membership)

# bonus points for colorizing nodes and edges by community
igraph::V(karate)$color <- colorjam::group2colors(igraph::membership(wc));
igraph::V(karate)$label.color <- jamba::setTextContrastColor(igraph::V(karate)$color);
igraph::V(karate)$frame.color <- jamba::makeColorDarker(igraph::V(karate)$color);
karate <- color_edges_by_nodes(karate);

# update graph layout
layout_xy <- igraph::layout_with_graphopt(karate);
igraph::graph_attr(karate, "layout") <- layout_xy;

jam_igraph(karate,
   edge_bundling="nodegroups",
   nodegroups=nodegroups_wc,
   use_shadowText=TRUE);

}
\seealso{
Other jam igraph functions: 
\code{\link{cnet2df}()},
\code{\link{cnet2im}()},
\code{\link{cnetplotJam}()},
\code{\link{cnetplot_internalJam}()},
\code{\link{color_edges_by_nodes_deprecated}()},
\code{\link{color_edges_by_nodes}()},
\code{\link{drawEllipse}()},
\code{\link{edge_bundle_bipartite}()},
\code{\link{enrichMapJam}()},
\code{\link{fixSetLabels}()},
\code{\link{flip_edges}()},
\code{\link{get_bipartite_nodeset}()},
\code{\link{igraph2pieGraph}()},
\code{\link{jam_igraph}()},
\code{\link{jam_plot_igraph}()},
\code{\link{layout_with_qfrf}()},
\code{\link{layout_with_qfr}()},
\code{\link{memIM2cnet}()},
\code{\link{mem_multienrichplot}()},
\code{\link{rectifyPiegraph}()},
\code{\link{relayout_with_qfr}()},
\code{\link{removeIgraphBlanks}()},
\code{\link{removeIgraphSinglets}()},
\code{\link{reorderIgraphNodes}()},
\code{\link{rotate_igraph_layout}()},
\code{\link{spread_igraph_labels}()},
\code{\link{subgraph_jam}()},
\code{\link{subsetCnetIgraph}()},
\code{\link{subset_igraph_components}()},
\code{\link{with_qfr}()}
}
\concept{jam igraph functions}
