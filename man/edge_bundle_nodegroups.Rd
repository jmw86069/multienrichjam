% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jamgraph-edgebundle.R
\name{edge_bundle_nodegroups}
\alias{edge_bundle_nodegroups}
\title{Bundle edges using node groups}
\usage{
edge_bundle_nodegroups(
  g,
  nodegroups,
  shape = NULL,
  params = NULL,
  midpoint = 0.5,
  detail = 10,
  draw_lines = TRUE,
  nodegroup_midpoints = NULL,
  linear_cor_threshold = 1,
  bundle_style = getOption("jam.bundle_style", "bezier"),
  bundle_self = FALSE,
  verbose = FALSE,
  debug = getOption("debug", FALSE),
  ...
)
}
\arguments{
\item{g}{\code{igraph} that contains layout coordinates in
graph attributes, stored as \code{igraph::graph_attr(g, "layout")}.}

\item{nodegroups}{\code{list} of node names, or object with
class \code{"communities"} as produced by \verb{igraph::cluster_*}
methods such as \code{igraph::cluster_walktrap()}. Note that
every node must be represented.}

\item{shape}{\code{character} (optional) used to override the \code{vertex.shape}
passed in \code{params}. It is recycled to the number of nodes,
for example by \code{igraph::vcount(g)}.}

\item{params}{\code{function} representing \code{igraph} plotting parameters
used at rendering time. The output is also produced by
\code{parse_igraph_plot_params()} for use in \code{jam_igraph()}
plotting, and is passed to other node and edge rendering
functions.}

\item{midpoint}{\code{numeric} vector of one or more values ranging
from \code{0} to \code{1} that define control point positions along the
line between two nodegroup center coordinates. When one nodegroup
contains only one node, this line segment is shortened to end
at that node border after clipping the corresponding node shape.
The position along the line is defined relative to the first node
in the edge, toward the second node in the edge.
Using \code{midpoint=0.5} guarantees the control point is the exact middle,
while \code{midpoint=c(0.2, 0.8)} will use two control points at 20\% and
80\% distance along the line segment resulting in an edge that more
closely follows the line segment.}

\item{detail}{\code{integer} number of intermediate points along
the spline to render for each edge.}

\item{draw_lines}{\code{logical} indicating whether to render the edge
splines after calculating them.}

\item{nodegroup_midpoints}{\code{list} experimental support for defining
specific control points used by bundled edges. Not fully implemented
as yet. In future, it will require two nodegroups to be defined
for each set of control point coordinates, with no requirement
for the location of control points.}

\item{linear_cor_threshold}{\code{numeric} value between 0 and 1.
Coordinates for each edge, and intermediate control point
coordinates are used in \code{xspline()} to create a curved spline
from node to node. However, when the nodes and intermediate
control points are already linear, the edge will be treated
as a linear edge. To test for linearity, \code{cor()} correlation
is calculated, and values at or above \code{linear_cor_threshold}
are considered linear.

The driving problem is when the control point is colinear with
two nodes, and the control point is positioned outside the two
nodes. Without this modification, the line would appear to pass
from one node beyond the other node, with an arrow (if directed)
pointing back to the other node from the opposite direction.}

\item{bundle_style}{\code{character} string describing the type of curvature
to use for edge bundles:
\itemize{
\item \code{"bezier"}: (default) calls \code{bezier::bezier()} to define a bezier
curve using the edge control points.
\item \code{"xspline"}: calls \code{graphics::xspline()} to define an XSpline curve
using the edge control points, however the method is  customized
to include each edge endpoint twice, which makes the intermediate
curve much rounder than normal.
\item \code{"angular"}: calls \code{graphics::xspline()} to define an XSpline curve
using the edge control points. This shape tends to appear angular,
thus the name.
\item \code{"bezierPath"}: calls \code{ggforce:::bezierPath()} when \code{ggforce} is
available, producing a bezier curve using the edge control points.
Note this method appears identical to \code{"bezier"} above, and will
likely be removed in a future release.
\item \code{"subway"}: experimental method that uses the \code{"angular"} appearance,
with more repeated intermediate control points intended to group
all bundled edges to the same linear segment. The intent is to "dodge"
edges along the line segment, similar to the appearance of subway maps,
however it is not fully implemented.
}}

\item{bundle_self}{\code{logical} to indicate whether edges that begin and
end in the same nodegroup should be bundled through the nodegroup
center coordinate.
\itemize{
\item \code{bundle_self=FALSE} forces all edges within a nodegroup to be
rendered as straight lines, therefore not using the nodegroup center
as the control point.
\item \code{bundle_self=TRUE} overrides the validation check that
requires the distance between center points of two nodegroups to
have distance at least 0.5\% the layout coordinate span. It can
be a visual aid to have connections bundle through the center
of the nodegroup, especially when the nodegroup is almost fully
connected.
}}

\item{verbose}{\code{logical} indicating whether to print verbose output.}

\item{debug}{\code{logical} indicating whether to plot debug output that
may be helpful in understanding the edge bundle control points.
To specify debug only for edge bundling, use the substring "bundl",
for example \code{options("debug"="bundling")}.}

\item{...}{additional arguments are ignored.}
}
\value{
\code{data.frame} with each edge spline point represented
on its own row, with breaks in edges defined by \code{NA} coordinates.
}
\description{
Bundle edges using node groups
}
\details{
This edge bundling technique relies upon some form of
node grouping, usually derived from network community
detection, or from bipartite nodesets (see
\code{get_bipartite_nodeset()} for details.)

Given a set of node groups, edges are bundled entering
and exiting each node group, along the linear path between
the two node group center positions, using a spline
function and intermediate control points.

The default spline uses the initial node positions, and the
midpoint along the line between the two respective node groups.
The midpoints can be adjusted with the argument \code{midpoint}
and a vector of one or more fractional positions between \code{0} and \code{1}.
A useful alternative is \code{midpoint=c(0.3, 0.7)} which adds
two control points along the linear path between node group
centers, and tends to make the edges bundle closer together
for a longer distance.

When used with bipartite nodesets, edges are bundled between
each nodeset and individual nodes. The edge bundling rules are
the same, with the default \code{midpoint=c(0.4, 0.6)} being centered at half
the distance between the nodeset center, and the single node.
In this case, the \code{midpoint} is directional, always pointing
from the nodeset to the single node, therefore can be adjusted
closer to the nodeset center with \code{midpoint=0.2} or closer to
the single node with \code{midpoint=0.8}.
}
\examples{
# using community detection
karate <- igraph::make_graph("Zachary")
igraph::V(karate)$name <- as.character(seq_len(igraph::vcount(karate)))

# run any igraph::cluster_*()
wc <- igraph::cluster_louvain(karate)
# define list
nodegroups_wc <- split(igraph::V(karate)$name, wc$membership)

# bonus points for colorizing nodes and edges by community
igraph::V(karate)$color <- colorjam::group2colors(igraph::membership(wc));
igraph::V(karate)$label.color <- jamba::setTextContrastColor(igraph::V(karate)$color);
igraph::V(karate)$frame.color <- jamba::makeColorDarker(igraph::V(karate)$color);
karate <- color_edges_by_nodes(karate);

# update graph layout
layout_xy <- igraph::layout_with_graphopt(karate);
igraph::graph_attr(karate, "layout") <- layout_xy;

jam_igraph(karate,
   edge_bundling="nodegroups",
   nodegroups=nodegroups_wc,
   use_shadowText=TRUE);

}
\seealso{
Other jam igraph functions: 
\code{\link{cnet2df}()},
\code{\link{cnet2im}()},
\code{\link{cnetplotJam}()},
\code{\link{cnetplot_internalJam}()},
\code{\link{color_edges_by_nodegroups}()},
\code{\link{color_edges_by_nodes_deprecated}()},
\code{\link{color_edges_by_nodes}()},
\code{\link{color_nodes_by_nodegroups}()},
\code{\link{communities2nodegroups}()},
\code{\link{drawEllipse}()},
\code{\link{edge_bundle_bipartite}()},
\code{\link{enrichMapJam}()},
\code{\link{fixSetLabels}()},
\code{\link{flip_edges}()},
\code{\link{get_bipartite_nodeset}()},
\code{\link{igraph2pieGraph}()},
\code{\link{jam_igraph}()},
\code{\link{jam_plot_igraph}()},
\code{\link{label_communities}()},
\code{\link{layout_with_qfrf}()},
\code{\link{layout_with_qfr}()},
\code{\link{mem2emap}()},
\code{\link{memIM2cnet}()},
\code{\link{mem_multienrichplot}()},
\code{\link{nodegroups2communities}()},
\code{\link{rectifyPiegraph}()},
\code{\link{relayout_with_qfr}()},
\code{\link{removeIgraphBlanks}()},
\code{\link{removeIgraphSinglets}()},
\code{\link{reorderIgraphNodes}()},
\code{\link{rotate_igraph_layout}()},
\code{\link{spread_igraph_labels}()},
\code{\link{subgraph_jam}()},
\code{\link{subsetCnetIgraph}()},
\code{\link{subset_igraph_components}()},
\code{\link{sync_igraph_communities}()},
\code{\link{with_qfr}()}
}
\concept{jam igraph functions}
