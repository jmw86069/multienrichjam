% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jamgraph-relayout-nodegroups.R
\name{relayout_nodegroups}
\alias{relayout_nodegroups}
\title{Relayout each nodegroup in a bipartite (Cnet) graph, experimental}
\usage{
relayout_nodegroups(
  cnet,
  nodegroups = NULL,
  repulse = 3.5,
  fix_set_nodes = TRUE,
  spread_labels = TRUE,
  add_edges = TRUE,
  edge_factor = 2,
  do_final_relayout = NULL,
  final_repulse = 3.5,
  apply_by_size = TRUE,
  byCols = c("-num_terms", "-num_nodes", "nodegroup"),
  verbose = FALSE,
  ...
)
}
\arguments{
\item{cnet}{\code{igraph} object with node layout already defined}

\item{nodegroups}{\code{list} of node names, or \code{communities} object,
passed to \code{communities2nodegroups()}.
When NULL, it checks for supporting data in this order:
\enumerate{
\item If graph attribute 'mark.groups' is defined, it is used.
\item If vertex attribute 'nodeType' exists, it calls
\code{get_cnet_nodeset()}.
\item Finally, it calls \code{igraph::cluster_optimal()}, hoping this
method will be appropriate for the graph size.
}}

\item{repulse}{\code{numeric} default 3.5, passed to \code{relayout_with_qfr()}}

\item{fix_set_nodes}{\code{logical} default TRUE, whether to fix all
nodes with nodeType=='Set' to prevent them from moving.}

\item{spread_labels}{\code{logical} default TRUE, whether to apply
\code{spread_igraph_labels()} after the relayout iterations are complete.}

\item{add_edges}{\code{logical} default TRUE, whether to add edges within
nodes of each nodegroup. The same is accomplished by setting
\code{edge_factor=0}.}

\item{edge_factor}{\code{numeric} default 2, used as the numerator in
new edge weights with equation \code{edge_factor/sqrt(n)} where 'n'
is the number of nodes in the nodegroup.
\itemize{
\item Set \code{edge_factor=0} or \code{add_edges=FALSE} to skip this step.
}}

\item{do_final_relayout}{\code{logical} default NULL, whether to apply
one more \code{relayout_with_qfr()} after each nodegroup is adjusted.
It uses \code{final_repulse}.}

\item{final_repulse}{\code{numeric} used when \code{do_final_relayout} is TRUE,
used as the 'repulse' argument in \code{relayout_with_qfr()}.}

\item{apply_by_size}{\code{logical} default TRUE, whether to apply the
relayout to nodegroups ordered by size, using \code{byCols} to sort.
\itemize{
\item The default applies layout such that nodegroups with the most terms
in \code{names(nodegroups)} are applied first, then largest to smallest
nodegroups.
\item For Cnet plots, Gene nodes in nodegroups connected
to the most Set nodes are adjusted first, then largest nodegroups,
then sorted by nodegroup name.
\item It is unclear if the order is useful, future iterations of
this approach may "move" other nodegroups aside first, then
re-introduce each nodegroup into the layout one by one.
Otherwise nodes could become "tangled" in the center, with
no ideal method to optimize separation by nodegroup.
}}

\item{byCols}{\code{character} vector used when \code{apply_by_size} is TRUE.
\itemize{
\item '-num_terms': reverse-order by the number of terms in each
nodegroup name, assuming comma-delimited terms.
\item '-num_nodes': reverse-order by the number of nodes in each nodegroup.
\item 'nodegroup': alphnumeric sort of the \code{names(nodegroups)}.
}}

\item{verbose}{\code{logical} whether to print verbose output.}

\item{...}{additional arguments are passed to
\code{communities2nodegroups()} for argument 'sep', or to
\code{spread_igraph_labels()} for arguments regarding node ordering, etc.}
}
\value{
\code{igraph} object with updated layout.
}
\description{
Relayout each nodegroup in a bipartite (Cnet) graph, experimental
}
\details{
This function iteratively re-applies a layout function
to each nodegroup in a graph, constraining the position of
all other nodes for each iteration.
Currently the layout uses \code{relayout_with_qfr()}, in future it
may use any layout function.

The purpose is to "encourage" nodes in a nodegroup to become
bundled together.

Strategy:
\itemize{
\item Each nodegroup is isolated, and \code{relayout_with_qfr()} is called
on nodes in each nodegroup, while constraining all other nodes so
they cannot move.
\item In theory, using the same \code{repulse}, the nodes would not move at all.
Changing the repulse force could encourage nodes to stay together.
\item By default \code{add_edges=TRUE} which adds phantom edges to connect all
nodes in a node group.
\itemize{
\item The edge weight is scaled down by the number
of nodes.
\item These phantom edges are intended to help 'encourage' the nodegroup
nodes to group together.
\item Otherwise, most layout algorithms are only focused on specific
edge forces, and not secondary forces which are common in Cnet plots.
\item For example, nodes in a nodegroup all share
the same network connections, however they are not otherwise
attracted to each other in a network layout. In absence of any
repulsive force, they would all be co-located. But with some
repulsive force, they are repelled from each other, and sometimes
end up radially positioned around the plot, and not grouped together.
\item The phantom edges add some minimal force for nodes to be
grouped closer together, and are removed once the layout is complete.
}
\item As a final polishing step, \code{do_final_relayout=TRUE} enables a final
round of global node layout, with \code{final_repulse}.
\itemize{
\item We observed that sometimes the nodegroups are too clumped,
in a big circular "ball" due to the phantom edge process above.
The final relayout is helpful to allow nodes to space out somewhat.
\item It may be helpful to pass \code{niter} to control the number of
layout iterations in this final step. The default is 500.
}
}
\subsection{Todo}{

Bonus points:
\itemize{
\item Determine if each nodegroup is "split" around another nodegroup.
If so, iterate that nodegroup using varying 'repulse' or other
strategies to attempt to minimize the issue.
}
}
}
\examples{
cnet <- make_cnet_test();
ns <- get_cnet_nodeset(cnet)
# mark.groups: highlight just one nodegroup
# nodegroups: enables the edge_bundling to work properly
jam_igraph(cnet, mark.groups=ns["SetA,SetB"], nodegroups=ns,
   main="One nodegroup is split")

cnet2 <- relayout_nodegroups(cnet, nodegroups=ns["SetA,SetB"], do_final_layout=TRUE, verbose=TRUE)
jam_igraph(cnet2, mark.groups=ns["SetA,SetB"], nodegroups=ns,
   main="This nodegroup is 'encouraged' to re-group")

# by default, it is applied to all nodes
cnet3 <- relayout_nodegroups(cnet)
jam_igraph(cnet3, mark.groups=ns, nodegroups=ns,
   main="Re-layout across all nodegroups")

}
\seealso{
Other jam cnet utilities: 
\code{\link{adjust_cnet_nodeset}()},
\code{\link{adjust_cnet_set_relayout_gene}()},
\code{\link{apply_nodeset_spacing}()},
\code{\link{bulk_cnet_adjustments}()},
\code{\link{get_cnet_nodeset}()},
\code{\link{get_cnet_nodeset_vector}()},
\code{\link{launch_shinycat}()},
\code{\link{make_cnet_test}()}
}
\concept{jam cnet utilities}
