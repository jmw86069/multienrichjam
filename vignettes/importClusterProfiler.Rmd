---
title: "Multienrichment with clusterProfiler"
name: importClusterProfiler
output:
  BiocStyle::html_document:
    df_print: kable
    fig_width: 10
    fig_height: 12
vignette: >
  %\VignetteIndexEntry{Multienrichment with clusterProfiler}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
use_dev <- "png";
if (requireNamespace("ragg", quietly=TRUE)) {
   use_dev <- "ragg_png";
}
knitr::opts_chunk$set(
   collapse=TRUE,
   comment="#>",
   fig.width=10,
   fig.height=12,
   out.width="100%",
   fig.align="center",
   dev=use_dev
)
```

```{r setup}
library(multienrichjam)
library(jamba);
# library(colorjam);
# suppressPackageStartupMessages(library(ComplexHeatmap))
options("warn"=-1)
```

# msigdbr Requirement

This guide requires the `msigdbr` R package from CRAN.

```{r check_msigdbr, cache=FALSE, results='asis'}
if (!requireNamespace("msigdbr", quietly=TRUE)) {
   jamba::printDebugHtml("The ", "msigdbr",
      " package is required for this vignette. Stopping here.")
   knitr::knit_exit()
}
```

# clusterProfiler enrichment

This document describes steps recommended for clusterProfiler
enrichment data, which include specific objects such as
`enrichResults` and others.

Refer to the
[clusterProfiler e-Book](https://yulab-smu.top/biomedical-knowledge-mining-book/index.html),
an outstanding and comprehensive guide to using
clusterProfiler to generate gene set enrichment data.

There are two general approaches:

1. Run `clusterProfiler::enricher()` for a `list` of experiments.
2. Use an existing `list` of `clusterProfiler::enricher()` results.


# clusterProfiler enrichment

## Prepare MSigDB Pathway Data

The example below demonstrates how to prepare canonical pathways from
[MSigDB](https://www.gsea-msigdb.org/gsea/msigdb)
to use for gene set enrichment. These pathways are used with a list of genes
in `Reese_genes` to test for enrichment.


The `msigdbr` R package is used to download necessary data,
following the guidance in the clusterProfiler e-Book:
[MSigDb analysis](https://yulab-smu.top/biomedical-knowledge-mining-book/universal-api.html#msigdb-analysis).
See `msigdbr::msigdbr()` for more details.

### Review MSigDB Collections

The `msigdbr` package offers convenient access to collections of
gene sets available from MSigDB, shown below.

```{r msigdbr-collections}
msigdb_collections <- msigdbr::msigdbr_collections(db_species="HS")
```

```{r msigdbr-collections-kdf, results='asis', echo=FALSE}
kable_coloring(
   caption="MSigDB Collections",
   row.names=FALSE,
   data.frame(msigdb_collections))
```

### MSigDB Canonical Pathways

This tutorial uses `collection = "C2"` because it
contains all canonical pathway gene sets from multiple sources.
The canonical pathways are then filtered by retaining the
subset with `gs_subcollection` containing `"CP"`.

There are two columns used by `clusterProfiler::enricher()`:

1. gs_name - the gene set name
2. gene - usually gene symbol

Using these two columns, the `data.frame` needs to retain only unique rows.

```{r msigdbr-c2, results='asis', eval=FALSE}
# C2 canonical pathways
msig_cp <- subset(
   msigdbr::msigdbr(
      species = "Homo sapiens",
      collection="C2"),
   grepl("CP", gs_subcollection))
msig_cp_gs <- unique(data.frame(msig_cp[, c("gs_name", "gene_symbol")]))
head(msig_cp_gs, 10)
```

For the purpose of this vignette, a subset of canonical
pathways are available using `data(msig_test)`, and should only
be used for this analysis.

```{r msigdbr-c2-demo, echo=FALSE, results='asis'}
data(msig_test)
kable_coloring(
   caption="MSigDB Canonical Pathways",
   row.names=FALSE,
   head(subset(msig_test, !duplicated(gs_name)), 10))
```

## Run enricher()

The [clusterProfiler documentation](https://yulab-smu.top/biomedical-knowledge-mining-book/universal-api.html#msigdb-ora)
for `enricher()` is straightforward for over-representation analysis (ORA).
Note that other clusterProfiler enrich* tools can be used, for example
`clusterProfiler::enrichKEGG()`, `clusterProfiler::enrichPC()`.

> The most important argument to include:  
>
> `pvalueCutoff=1`
>
> This option retains all enrichment results without filtering.  
> The P-value will be filtered later by multienrichjam.

This example uses `Reese_genes` containing genes identified
by [Reese *et al* 2019](https://doi.org/10.1016/j.jaci.2018.11.043) in
**Epigenome-wide meta-analysis of DNA methylation and childhood asthma**
https://doi.org/10.1016/j.jaci.2018.11.043.

The data are stored as a `list` of significant genes, so we iterate the
list using `lapply()`.

```{r run_enrichr, results='asis'}
# Gene hit lists
data(Reese_genes)

# enricher() for each element of a list
erlist <- lapply(Reese_genes, function(igenes){
   er <- clusterProfiler::enricher(igenes,
      pvalueCutoff=1,
      TERM2GENE=msig_test,
      minGSSize=5, maxGSSize=5000)
})
```

You may also run a specific enrichment function in `clusterProfiler` such as
`clusterProfiler::enrichPC()` which automatically uses **Pathway Commons**
pathways.

```{r run-enrichr-pc, results='asis'}
data(Reese_genes)

# Optionally run enrichPC() which tests PathwayCommons
erlist2 <- lapply(Reese_genes, function(igenes){
   er <- clusterProfiler::enrichPC(igenes,
      pvalueCutoff=1,
      minGSSize=5, maxGSSize=5000)
})
```

# Run multiEnrichMap()

The `erlist` from the previous step will be the input to `multiEnrichMap()`.

```{r run-mem}
mem <- multiEnrichMap(erlist,
   pvalueColname="qvalue",
   p_cutoff=0.01,
   cutoffRowMinP=0.2,
   min_count=2,
   topEnrichN=20)
```

The default summary for `mem` describes the contents, shown below:

```{r run-mem-summary}
mem
```


## Mem Plot Folio

The `mem_plot_folio()` represents a key step in the analysis workflow.

Pathway clusters are defined by analyst parameters:

* The number of pathways clusters
* The relative weight of the gene-pathway incidence matrix.
* The method used for clustering.

Mem Plot Folio then provides a series of visualizations, described
in detail in `mem_plot_folio()`.

**Only the first four plots are shown below** using `do_which=c(1, 2, 3, 4)`.

```{r, mem-folio, fig.height=12, fig.width=10, out.width="100%", fig.alt=c("mem_plot_folio, plot 1, enrichment heatmap", "mem_plot_folio, plot 2, Gene-Pathway heatmap", "mem_plot_folio, plot 3, Cnet plot with Cluster Letters", "mem_plot_folio, plot 4, Cnet plot with Cluster Summary Labels")}
mpf <- mem_plot_folio(mem,
   pathway_column_split=4,
   column_cex=0.4, row_cex=0.4,
   row_names_max_width=grid::unit(9, "cm"),
   column_names_max_height=grid::unit(4, "cm"),
   node_factor=2.5,
   label_factor_l=list(nodeType=c(Set=0.7, Gene=1.5)),
   use_shadowText=TRUE,
   do_which=c(1, 2, 3, 4),
   main="Canonical Pathways")
```



## Cnet Cluster Plot

The Cnet Cluster Plot is often the basis for manuscript figures.
The typical workflow is demonstrated below.

* `mpf4 <- mem_plot_folio(mem, do_which=4)` is used to generate the Cnet data.
* `cnet <- mpf4$cnet_collapsed_set` retrieves the Cnet `igraph` object.

```{r, cnet-cluster-data}
# generate the data
mpf4 <- mem_plot_folio(mem,
   pathway_column_split=4,
   do_which=c(4),
   do_plot=FALSE)

# extract the cnet
cnet <- mpf4$cnet_collapsed_set;
```

`jam_igraph()` is a custom plotting function with enhancements:

* `node_factor=2` multiplies node size by 2.
* `label_dist_factor=2` multiplies label distance from node center by 5.
* `use_shadowText=TRUE` uses shadowing around the text labels.
* `label_factor_l` resizes the node labels by 'nodeType' for Gene and Set.
* It applies edge bundling, which helps with large networks.
* It plots using vectorized optimization.

```{r, cnet-cluster, fig.height=12, fig.width=10, out.width="100%", fig.alt="Cnet cluster plot suitable for customization."}
# jam_graph instead of plot()
jam_igraph(cnet,
   node_factor=2,
   use_shadowText=TRUE,
   label_dist_factor=5,
   label_factor_l=list(nodeType=c(Gene=2, Set=0.8)))

```


# ShinyCat for Custom Cnet Layout

The R-shiny Cnet Adjustment Tool **ShinyCat** is intended to help polish
the Cnet plot layout when making a final figure.

The R-shiny app uses several functions:

* `nudge_igraph_node()`: mode individual nodes
* `adjust_cnet_nodeset()`: adjust spacing, position, rotation of a nodeset
* `reorder_igraph_nodes()`: sort nodes in a group by color
* `spread_igraph_labels()`: arrage labels radially away from incoming edges
* `bulk_cnet_adjustments()`: several operations applied in bulk

> Make sure to assign the output to a variable, or to click "Save RData"
from within the R-shiny app. For example:

```{r shinycat-1, eval=FALSE}
output_env <- launch_shinycat(g=cnet)
```

The output is stored in an `environment` called `output_env`.

```{r shinycat-2, eval=FALSE}
# obtain the output data
adj_cnet <- output_env$adj_cnet;
```


Then the new Cnet plot can be plotted, for example:

```{r shinycat-3, eval=FALSE}
# jam_graph
jam_igraph(adj_cnet,
   node_factor=2,
   use_shadowText=TRUE,
   label_factor_l=list(nodeType=c(Gene=2, Set=1)))
```

## ShinyCat Screenshot

An example of ShinyCat in action is shown below.

```{r shinycat-screen-2, echo=FALSE, out.width="100%", fig.alt="Screenshot of ShinyCat in action, with a Cnet network plot in the center, and several inputs on the left to adjust the layout."}
knitr::include_graphics("shinycat-2.png")
```
