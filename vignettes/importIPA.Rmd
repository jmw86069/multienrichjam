---
title: "How to import and use Ingenuity IPA enrichment data"
output:
  rmarkdown::html_vignette:
    df_print: kable
vignette: >
  %\VignetteIndexEntry{How to import and use Ingenuity IPA enrichment data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
# ragg_png <- function(..., res = 192) {
#   ragg::agg_png(..., res = res, units = "in")
# }

knitr::opts_chunk$set(
  collapse=TRUE,
  comment="#>",
   fig.height=12,
   fig.width=10,
   fig.align="center",
   dev="ragg_png"
)
```

```{r setup}
library(multienrichjam);
library(jamba);
library(colorjam);
suppressPackageStartupMessages(library(ComplexHeatmap));
options("stringsAsFactors"=FALSE, "warn"=-1);
```

## Import and use Ingenuity IPA enrichment data

This document describes steps recommended for using Ingenuity
IPA enrichment data.

Ingenuity IPA enrichment data can be exported using a function
`"Export All"` which by default creates one text file,
concatenating each enrichment table into one large file.

This workflow demonstrates the import process using two
IPA enrichment files used by Reese et al 2019
https://doi.org/10.1016/j.jaci.2018.11.043
to compare enrichment results in newborns to older children.

It therefore requires IPA enrichment results have already
been exported in text format from IPA.

### Import IPA data from text files

To import an IPA text file, use `importIPAenrichment()`:

```{r, import_ipa_1}
newborn_txt <- system.file("extdata",
   "Newborns-IPA.txt",
   package="multienrichjam");
newborn_dfl <- importIPAenrichment(newborn_txt);
```

The result is a list of `data.frame` objects, where each
`data.frame` represents one enrichment test. A convenient
way to see the dimensions of each `data.frame` is with
the function `jamba::sdim()`:

```{r, ipa_1_sdim}
sdim(newborn_dfl);
```

For MultiEnrichMap, we typically want to analyze multiple
IPA enrichment files, so we can wrap the call in
an `lapply()` function:

```{r, import_ipa_1_2}
newborn_txt <- system.file("extdata",
   "Newborns-IPA.txt",
   package="multienrichjam");
olderchildren_txt <- system.file("extdata",
   "OlderChildren-IPA.txt",
   package="multienrichjam");
ipa_files <- c(Newborns=newborn_txt,
   OlderChildren=olderchildren_txt)

ipa_l <- lapply(ipa_files, importIPAenrichment);
```

Now we can check the dimensions within each list using
`jamba::ssdim()`:

```{r, ipa_ssdim}
ssdim(ipa_l);
```

In most cases, each IPA file should contain the same
enrichment tests, for example `"Canonical Pathways"`,
`"Upstream Regulators"`, `"Diseases and Bio Functions"`,
etc. However, it is not always the case, so it is
recommended to check and verify each IPA file contains
at least the enrichment tests needed for downstream analysis.

## Analyze IPA enrichments from one enrichment test

IPA performs multiple enrichment tests, which are
done independently and with unique assumptions
and caveats. Therefore, I recommend using one
enrichment test at a time in MultiEnrichMap.

Extract one `data.frame` from each result:

```{r, extract_canonical}
library(igraph)
## Take only the Ingenuity Canonical Pathways
enrichList_canonical <- lapply(ipa_l, function(i){
   i[["Canonical Pathways"]];
});
sdim(enrichList_canonical);

## Convert data.frame to enrichResult
## multienrichjam::enrichDF2enrichResult
er_canonical <- lapply(enrichList_canonical, function(i){
   enrichDF2enrichResult(i,
      keyColname="Name",
      pvalueColname="P-value",
      geneColname="geneNames",
      geneRatioColname="Ratio",
      pvalueCutoff=1)
});
sdim(er_canonical);
kable_coloring(
   head(as.data.frame(er_canonical[[1]])),
   caption="Top 10 rows of enrichment data",
   row.names=FALSE) %>%
   kableExtra::column_spec(column=seq_len(ncol(er_canonical[[1]])),
      border_left="1px solid #DDDDDD",
      extra_css="white-space: nowrap;")

```

### run multiEnrichMap()

Now given a list of `data.frame` results, we can
run `multiEnrichMap()`:

```{r, mem_canonical, fig.height=9, fig.width=10}
mem_canonical <- multiEnrichMap(er_canonical,
   enrichBaseline=1,
   cutoffRowMinP=0.05,
   topEnrichN=20)
```

Output is a `list` containing summary results.

```{r, mem_sdim}
kable_coloring(
   sdim(mem_canonical),
   caption="sdim(mem_canonical)") %>%
   kableExtra::column_spec(column=seq_len(4),
      border_left="1px solid #DDDDDD",
      extra_css="white-space: nowrap;")
```

### Mem Plot Folio

The `mem_plot_folio()` represents a key step in the analysis workflow.
Several downstream results are directly dependent upon the options
chosen here:

Pathway clusters are defined by analyst parameters:

* The number of pathways clusters
* The relative weight of the gene-pathway incidence matrix.
* The method used for clustering.

Mem Plot Folio then provides a series of visualizations:

1. **Enrichment P-value heatmap** often as a dot plot
2. **Gene-pathway heatmap**, clustered by column and by row
3. **Cnet cluster plots**

   a. Pathway clusters are labeled by `LETTERS` ("A", "B", "C", "D", etc.)
   b. The second plot labels clusters by the top `n` pathway names
   c. The third plot is (b) and hides the gene labels.

4. **Cnet exemplar plots**

   * Includes 1 exemplar pathway per cluster.
   * Includes 2 exemplars per cluster.
   * Includes 3 exemplars per cluster.

5. **Cnet per cluster**

   * One plot for each pathway cluster

```{r, mem_folio, fig.height=16, fig.width=10}
mem_canonical_plots <- multienrichjam::mem_plot_folio(mem_canonical,
   pathway_column_split=4,
   column_cex=0.7,
   node_factor=1,
   use_shadowText=TRUE,
   label_factor=1.2,
   do_which=c(1:5),
   verbose=TRUE,
   main="Canonical Pathways");
```

The object returned `mem_canonical_plots` is a `list`
of the graphical objects.


### Commentary on the "Plot Folio"

#### Where is Enrich Map?

In practice, we rarely find benefit from the multi-enrichment map.
The network shows pathways connected to pathways based upon Jaccard overlap
of the genes involved in enrichment of each pathway.

This network view was often disorganized, not clearly clustered,
and lacked ability to see which genes drive the overlaps between
pathways.

Perhaps it works best for the highly structured Gene Ontology (GO),
but in our hands GO was just not insightful for the broad range of
experiments we were analyzing.

#### Concept network (Cnet)

We gravitated toward the Cnet plot, a clever idea by Dr. Guangchang Yu
to visualize pathways connected to genes, where genes also connect
naturally to other pathways.

For many of our collaborators, this plot is visually intuitive.
It also answers the next question people often have:

>"What are the shared genes?"

Our subtle customization is to color genes by enrichment
to show which genes are shared or unique across enrichments.

The gene nodes are sorted by color, and optionally by border,
to help organize patterns.

#### Cnet cluster plot

The evolution of Cnet plots led to two conceptual ideas,
both driven by the "too many pathways" problem:

1. **Cnet using "exemplar pathways"**

   * This option is not comprehensive, as it only shows a subset
   of pathways.
   * This option will not show every gene involved in enrichment.
   * Its main utility is to produce a clean figure.
   Ultimately, this is also a core goal of multienrichjam.
   * This option is ideal when there are relevant pathways known
   to be relevant to the experiment, and when Option 2 (below)
   is too complex.
   * Option 1 is the path chosen by the `ggtangle` component of the
   `clusterProfiler` suite by Dr. Yu.
   It displays the top N pathways, with default `showCategory=5`.
   In our experience, the "top N" are not always the most
   representative, nor the most interesting.
   So we extended multienrichjam accordingly.

2. **Cnet using pathway clusters**

   * This option is intended to be more comprehensive,
   less complex than plotting 20 pathways individually,
   but more complex than "Cnet exemplars" above.
   * This option will show every gene involved in enrichment.
   * This option is the main utility of multienrichjam.
   * Pathways are clustered based upon the genes they contain.
   The approach is similar to Enrichment Map (Bader lab) use of
   Jaccard overlap.
   However, clustering is a rich field with many important
   techniques not captured by a simple overlap coefficient.

Option 2 has several important benefits

* **Reduces redundancy among pathways.**

   * When the genes involved in pathway enrichment
   are identical across several pathways,
   they naturally cluster together.
   * Over much time, we observed that gene-pathway clustering provides
   a rich overview of the data involved, and gives insight into
   the underlying pathways and supporting data.

* **Avoids clustering by P-value**

   * To be frank, our original approach was to plot the P-value
   matrix of test versus pathway.
   As a heatmap, it naturally  provides clusters, and it sometimes
   fortuitously appears biologically relevant.
   * **We learned that clustering by P-value is incorrect.**
   Instead, we recommend using the underlying gene content of the pathways.
   The purpose is to group pathways conceptually, and enrichment P-value
   is not an indication of biology.

* **Provides functional sub-groups for interpretation.**

   * Ideally, nearly identical pathways are grouped together and
   are "easily summarized" by a scientist.
   * More often, pathway clusters contain similar pathways, grouped because
   they also share "core genes" across these pathways.
   * This is an exciting finding in itself, and turns out to be the major
   step forward in interpreting pathway enrichment findings.
   Unfortunately, it doesn't provide an "easy summary" to use as a label.

### Cnet Cluster Plot

The Cnet Cluster Plot is often the focus of manuscript figures.
The typical workflow is demonstrated below.

```{r, cnet_cluster, fig.height=12, fig.width=10}
# generate the data
mpf4 <- mem_plot_folio(mem_canonical,
   do_which=c(4),
   do_plot=FALSE)

# extract the cnet
cnet <- mpf4$cnet_collapsed_set;

# jam_graph
jam_igraph(cnet,
   node_factor=2,
   use_shadowText=TRUE,
   label_factor_l=list(nodeType=c(Gene=2, Set=1)))

```

#### ShinyCat

The R-shiny Cnet Adjustment Tool **ShinyCat**.

There are several functions to help customize a Cnet `igraph` object,
however these are more easily applied by `launch_shinycat()`.

Make sure to assign the output to a variable, or to click "Save RData"
from within the R-shiny app.

```{r shinycat, eval=FALSE}
output_env <- launch_shinycat(g=cnet)

# obtain the output data
adj_cnet <- output_env$adj_cnet;

# jam_graph
jam_igraph(adj_cnet,
   node_factor=2,
   use_shadowText=TRUE,
   label_factor_l=list(nodeType=c(Gene=2, Set=1)))

```


### Multi-Enrichment Map

We can view the "Multi Enrichment Map" itself
with `mem_multienrichplot()`.

This network connects pathways when they meet a Jaccard
overlap coefficient threshold based upon the shared genes
between the pathways.
The default overlap is stored by `multiEnrichMap()`
in the output object `mem_canonical`.


```{r, mem_plot_1, fig.height=12, fig.width=10}
g <- mem_multienrichplot(mem_canonical,
   do_plot=FALSE,
   overlap=0.3,
   node_factor=2,
   repulse=3.5)
jam_igraph(g,
   node_factor=2,
   use_shadowText=TRUE)
title(main="overlap=0.3")
```

You can provide the Jaccard overlap threshold directly,
with argument `overlap`. Values should be between 0 and 1.

The threshold can be estimated by `mem_find_overlap()`,
based upon network connectivity.

```{r, mem_plot_1b, fig.height=12, fig.width=10}
use_overlap <- mem_find_overlap(mem_canonical);
g <- mem_multienrichplot(mem_canonical,
   overlap=use_overlap,
   do_plot=FALSE,
   node_factor=3,
   repulse=3.5)
jam_igraph(g,
   node_factor=3,
   use_shadowText=TRUE)
title(main=paste0("overlap=", use_overlap))
```


Notice there are distinct subnetworks, called "components",
which are not connected to each other.

You can pull out a component with `subset_igraph_components()`.
Components are ordered by size, largest to smallest,
so you can keep the largest using argument `keep=1`,
or the second largest with `keep=2`, and so on.

We also call two other helper functions:

1. `removeIgraphBlanks()`

   * removes blank colors from multi-color
   nodes, such as pie nodes, or colored rectangle nodes.
   * It helps show only the remaining colors without the whitespace.

2. `relayout_with_qfr()`

   * Fruchterman-Reingold layout, with argument `repulse` used
   to adjust the spacing between nodes.
   * Also updates other useful attributes, and spreads the node labels
   to reduce label overlaps.

```{r, mem_plot_2}
## You can alternatively pull out any other component
g_sub <- subset_igraph_components(g, keep=1);

## Re-apply network layout, and remove blank colors
g_sub <- relayout_with_qfr(repulse=3.5,
   removeIgraphBlanks(g_sub))

## Plot
jam_igraph(g_sub,
   node_factor=3,
   label_factor=2,
   use_shadowText=TRUE)
```



#### Enrichment P-value Heatmap

`mem_enrichment_heatmap()` produces a heatmap with Enrichment
versus pathway, with -log10(P-value) in the heatmap.

It is also provided by:  
`mem_plot_folio(mem, do_which=1)`

Argument `p_cutoff` is used to set the Pvalue, by default
it inherits the same threshold from the data provided.
Cells are only shaded with the P-value is below the threshold,
making it clear which entries are significant.
below which cells are colorized -- every P-value above
this threshold is not colored, and displayed as white,
even when the P-value is less than 1.

```{r, enrich_hm}
mem_enrichment_heatmap(mem_canonical,
   p_cutoff=0.05);
```

The same data can be plotted as a heatmap.

```{r, enrich_hm_1}
mem_enrichment_heatmap(mem_canonical,
   style="heatmap",
   p_cutoff=0.05);
```


Argument `color_by_column=TRUE` applies the
color gradient to each column, using `colorV` colors defined
in from `multiEnrichMap()`.

```{r, enrich_hm_2}
memhm <- mem_enrichment_heatmap(mem_canonical,
   style="heatmap",
   color_by_column=TRUE);
```


#### Gene-Pathway Heatmap

We can view the pathway-gene matrix using the function

`mem_gene_path_heatmap()` produces a heatmap of the pathway-gene
incidence matrix. This heatmap is the core of multienrichjam.

It is also provided by:  
`mem_plot_folio(mem, do_which=2)`

The function will estimate the number of pathway clusters,
but can be customized:

* `column_split=3` will produce 3 pathway clusters.
* `row_split=10` will produce 10 gene clusters.

Colors across the top of the heatmap indicate
enrichment P-values.

Colors on the left of the heatmap indicate which genes were
present in each enrichment test.
When directional gene hits are provided, the left of the heatmap
will also indicate directionality.

```{r, mem_hm, fig.height=14, fig.width=10}
hm <- mem_gene_path_heatmap(mem_canonical,
   column_cex=0.5,
   row_cex=0.6);
ComplexHeatmap::draw(hm,
   merge_legends=TRUE)
```

As a follow-up analysis, you can pull out each pathway
cluster from the heatmap itself, using `heatmap_column_order()`:

```{r, mem_hm_sets}
hm_sets <- heatmap_column_order(hm);
hm_sets;
```

### Full Cnet plot

The Concept network (Cnet) plot shows every pathway-gene relationship.

The helper function `memIM2cnet()` creates a Cnet plot
from the `mem_canonical` output.
Here, we also pipe the result through other helper functions:

* `fixSetLabels()` applies pathway label word wrap
* `relayout_with_qfr()` applies network layout and adjusts node labels
* `removeIgraphBlanks()` removes blank colors from the `igraph` nodes

```{r, cnet_plot_1, fig.height=10, fig.width=8}
#cnet <- mem_canonical$multiCnetPlot1b;
cnet <- mem_canonical %>% 
   memIM2cnet() %>%
   fixSetLabels() %>%
   removeIgraphBlanks() %>%
   relayout_with_qfr(repulse=4);

withr::with_par(list(mar=c(5,4,4,2)+0.1), {
   jam_igraph(cnet,
      use_shadowText=TRUE,
      node_factor=0.5,
      vertex.label.cex=0.6);
   mem_legend(mem_canonical);
})
```

Extract the largest connected subnetwork.

```{r, cnet_plot_2, fig.height=10, fig.width=8}
g2 <- cnet;
g2_sub <- subset_igraph_components(cnet, keep=1)

#plot(g2_sub);
jam_igraph(g2_sub,
   use_shadowText=TRUE,
   label_factor=0.5,
   node_factor=0.5);
```

#### Subset Cnet by Cluster

Subset the pathway nodes with `subsetCnetIgraph()`,
using `hm_sets` defined above.

```{r, cnet_plot_1_custom, fig.height=10, fig.width=8}
cnet_sub <- subsetCnetIgraph(cnet,
   repulse=3.5,
   includeSets=unlist(hm_sets[c("A")]));
jam_igraph(cnet_sub,
   node_factor=1,
   use_shadowText=TRUE,
   label_dist_factor=3,
   label_factor=1.3);
mem_legend(mem_canonical);
```


#### Subset Cnet Options

Subset the pathway nodes with `subsetCnetIgraph()`,
using a custom subset of pathways.

Alternatively, subset by other network attributes:

* `minSetDegree=6`: pathways with at least 6 genes
* `minGeneDegree=2`: genes present in 2 or more pathways (not used here).

Other useful defaults:

* `remove_singlets=TRUE`: remove singlet nodes with no connections.
* `force_relayout=TRUE`: re-calculated the layout.
* `do_reorder=TRUE`: re-order nodes by color.
* `spread_labels=TRUE`: re-position labels away from incoming edges
* `remove_blanks=FALSE`: optionally remove blank colors from pie nodes.

```{r, subnet, fig.height=10, fig.width=8}
cnet3 <- multienrichjam::subsetCnetIgraph(cnet,
   repulse=5,
   minSetDegree=6,
   minGeneDegree=1);
jam_igraph(cnet3,
   node_factor=0.7,
   use_shadowText=TRUE);
mem_legend(mem_canonical);
```

### jam_igraph() for igraph plots

`jam_igraph()` is a customized `igraph::plot()`, with benefits:

* `edge_bundling="connections"` (default) improves the rendering of edges
by bundling edges from node clusters, so they are drawn with
a bezier curve
* `use_shadowText=TRUE` (optional) will draw labels with a contrasting border
to improve legibility of text labels
* `rescale=FALSE` (default) keeps the network layout aspect ratio
instead of scaling the coordinates to fit the size.
of the plot window. It also properly scales the node and edge sizes.
* convenient resizing:

   * `label_factor`: adjusts `label.cex` by a multiplier
   * `node_factor`: adjusts `node.size` by a multiplier
   * `edge_factor`: adjusts `edge.width` by a multiplier
   * `label_dist_factor` re-scales the `label.dist` values by a multiplier

#### Simple resizing

Consider the following changes, demonstrated below:

* `node_factor=2`: nodes 2x larger
* `edge_factor=2`: edges 2x wider
* `label_factor=1.2`: labels 20% larger
* `use_shadowText=TRUE`: shadow text labels
* `label_dist_factor=5`: label distance 5x farther from node center

```{r, jam_igraph_1, fig.height=10, fig.width=8}
jam_igraph(cnet3,
   node_factor=2,
   edge_factor=2,
   label_factor=1.2, 
   label_dist_factor=5,
   use_shadowText=TRUE)
```

#### Colored edges

Colorize edges based upon the node colors, inspired by the Gephi
netowrk visualization tool.

```{r, jam_igraph_2, fig.height=10, fig.width=8}
jam_igraph(color_edges_by_nodes(cnet3, alpha=0.7),
   edge_bundling="connections",
   edge_factor=2,
   node_factor=2,
   label_factor=1.2, 
   label_dist_factor=5,
   use_shadowText=TRUE)
```

