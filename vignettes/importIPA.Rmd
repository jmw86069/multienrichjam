---
title: "How to use Ingenuity IPA enrichment results"
name: importIPA
output:
  BiocStyle::html_document:
    df_print: kable
vignette: >
  %\VignetteIndexEntry{How to import and use Ingenuity IPA enrichment data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
# ragg_png <- function(..., res = 192) {
#   ragg::agg_png(..., res = res, units = "in")
# }

knitr::opts_chunk$set(
   collapse=TRUE,
   comment="#>",
   fig.height=12,
   fig.width=10,
   fig.align="center",
   dev="ragg_png"
)
```

```{r setup}
library(multienrichjam);
library(jamba);
library(colorjam);
suppressPackageStartupMessages(library(igraph));
suppressPackageStartupMessages(library(ComplexHeatmap));
options("stringsAsFactors"=FALSE, "warn"=-1);
```

# Import Ingenuity IPA data

This document describes steps recommended for using Ingenuity
Pathway Analysis (IPA) enrichment data.

Ingenuity IPA enrichment results should be exported from the IPA
app:

* Open an IPA pathway analysis result.
* Click `"Export All"` at the top-right of the menu bar.
* Choose either "Text .txt" or "Excel".

   * The Excel file must be`.xlsx` format.

* Save each enrichment result to a separate file.

This workflow demonstrates the import process using two
IPA enrichment files used by
[Reese et al 2019](https://doi.org/10.1016/j.jaci.2018.11.043)
https://doi.org/10.1016/j.jaci.2018.11.043
to compare enrichment results in newborns to older children.

## Import IPA data

To import an IPA text file, use `importIPAenrichment()`.
It works the same when importing Excel `.xlsx` format.

```{r, import_ipa_1}
newborn_txt <- system.file("extdata",
   "Newborns-IPA.txt",
   package="multienrichjam");
newborn_dfl <- importIPAenrichment(newborn_txt);
```

The result is a `list`, named by the IPA analysis.
Each element contains one `data.frame` with analysis results.
Shown below is a summary of results, with number of rows and columns,
created with `jamba::sdim()`.

```{r, ipa_1_sdim}
sdim(newborn_dfl);
```

In `multienrichjam`, you may want to analyze multiple IPA analyses.
The example below uses `lapply()` to import multiple IPA files.

```{r, import_ipa_1_2}
newborn_txt <- system.file("extdata",
   "Newborns-IPA.txt",
   package="multienrichjam");
olderchildren_txt <- system.file("extdata",
   "OlderChildren-IPA.txt",
   package="multienrichjam");

ipa_files <- c(Newborns=newborn_txt,
   OlderChildren=olderchildren_txt)

ipa_l <- lapply(ipa_files, importIPAenrichment);
```

A summary of the list of lists is shown below, using
`jamba::ssdim()`:

```{r, ipa_ssdim}
ssdim(ipa_l);
```


## Analyze IPA enrichments from one enrichment test

IPA performs multiple types of analyis, and we recommend using
one type for multienrichjam, starting with "Canonical Pathways".

Other data available for use:

* **"Canonical Pathways:**: IPA curated pathways (most common*).
* **"Upstream Regulators"**: IPA curated regulators that are predicted
to have 'upstream' effects in cell signaling.
* **"Diseases and Bio Functions"**: IPA curated disease-associated
pathways, which include category and sub-category annotations.
* **"Tox Functions"**: IPA curated toxicity-associated
pathways, which also include category and sub-category annotations.

**"Analysis Ready Molecules"**: is a `data.frame` that contains the
IPA gene cross-reference, which stores what *you* called a gene, and
what *IPA* recognized for their analysis.

* The default `revert_ipa_xref=TRUE` will convert IPA gene symbol to
*your* gene symbol as provided to IPA.
* If you provided microarray or platform identifiers, such as
Affymetrix `'1007_s_at'` or Agilent `'ID A_14_P109686'`, you may
try `revert_ipa_xref=FALSE`, which will retain the IPA gene symbol.

Extract 'Canonical Pathways' from each IPA result:

```{r, extract_canonical}
## Take only the Ingenuity Canonical Pathways
enrichList_canonical <- lapply(ipa_l, function(i){
   i[["Canonical Pathways"]];
});
sdim(enrichList_canonical);
```

### Convert to enrichResult (optional)

Each `data.frame` can be converted to `enrichResult`.
It is not strictly necessary, but may be useful to use with
functions related to `clusterProfiler`, for example `ggtangle::cnetplot()`.

This option may be useful to review the conversion.

```{r, extract_canonical_er}
## Convert data.frame to enrichResult
## multienrichjam::enrichDF2enrichResult
er_canonical <- lapply(enrichList_canonical, function(i){
   enrichDF2enrichResult(i,
      keyColname="Name",
      pvalueColname="P-value",
      geneColname="geneNames",
      geneRatioColname="Ratio",
      pvalueCutoff=1)
});
sdim(er_canonical);
kable_coloring(
   head(as.data.frame(er_canonical[[1]])),
   caption="Top 10 rows of enrichment data",
   row.names=FALSE) %>%
   kableExtra::column_spec(column=seq_len(ncol(er_canonical[[1]])),
      border_left="1px solid #DDDDDD",
      extra_css="white-space: nowrap;")

```

# Run multiEnrichMap()

Now given a list of `data.frame` results, we can
run `multiEnrichMap()`:

```{r, mem_canonical, fig.height=9, fig.width=10}
mem_canonical <- multiEnrichMap(er_canonical,
   enrichBaseline=1,
   p_cutoff=0.05,
   topEnrichN=10)
```

Output is a `list` containing summary results.

```{r, mem_sdim}
kable_coloring(
   sdim(mem_canonical),
   caption="sdim(mem_canonical)") %>%
   kableExtra::column_spec(column=seq_len(4),
      border_left="1px solid #DDDDDD",
      extra_css="white-space: nowrap;")
```

## Mem Plot Folio

The `mem_plot_folio()` represents a key step in the analysis workflow.
Several downstream results are directly dependent upon the options
chosen here:

Pathway clusters are defined by analyst parameters:

* The number of pathways clusters
* The relative weight of the gene-pathway incidence matrix.
* The method used for clustering.

Mem Plot Folio then provides a series of visualizations:

1. **Enrichment P-value heatmap** often as a dot plot
2. **Gene-pathway heatmap**, clustered by column and by row
3. **Cnet cluster plots**

   a. Pathway clusters are labeled by `LETTERS` ("A", "B", "C", "D", etc.)
   b. The second plot labels clusters by the top `n` pathway names
   c. The third plot is (b) and hides the gene labels.

4. **Cnet exemplar plots**

   * Includes 1 exemplar pathway per cluster.
   * Includes 2 exemplars per cluster.
   * Includes 3 exemplars per cluster.

5. **Cnet per cluster**

   * One plot for each pathway cluster

**Only the first four plots are shown** by using `do_which=c(1:4)`.

```{r, mem-folio, fig.height=12, fig.width=8, fig.alt="Mem plot folio showing the first four plots"}
mem_canonical_plots <- mem_plot_folio(mem_canonical,
   pathway_column_split=4,
   column_cex=0.4, row_cex=0.4,
   row_names_max_width=grid::unit(9, "cm"),
   column_names_max_height=grid::unit(4, "cm"),
   node_factor=2.5,
   label_factor_l=list(nodeType=c(Set=0.7, Gene=1.5)),
   use_shadowText=TRUE,
   do_which=c(1, 2, 3, 4),
   main="Canonical Pathways");
```

The object returned `mem_canonical_plots` is a `list`
of the graphical objects.

# Customing Mem Plots

## Cnet Cluster Plot

The Cnet Cluster Plot is often the focus of manuscript figures.
The typical workflow is demonstrated below.

```{r, cnet-cluster, fig.height=12, fig.width=10, fig.alt="Cnet cluster network extracted from mem_plot_folio() to use for custom figures."}
# generate the data
mpf4 <- mem_plot_folio(mem_canonical,
   do_which=c(4),
   do_plot=FALSE)

# extract the cnet
cnet <- mpf4$cnet_collapsed_set;

# jam_graph
jam_igraph(cnet,
   node_factor=2,
   use_shadowText=TRUE,
   label_factor_l=list(nodeType=c(Gene=2, Set=1)))

```


## Enrichment P-value Heatmap

`mem_enrichment_heatmap()` produces a heatmap with Enrichment
versus pathway, with -log10(P-value) in the heatmap.

It is also provided by:  
`mem_plot_folio(mem, do_which=1)`

Argument `p_cutoff` is used to set the Pvalue, by default
it inherits the same threshold from the data provided.
Cells are only shaded with the P-value is below the threshold,
making it clear which entries are significant.
below which cells are colorized -- every P-value above
this threshold is not colored, and displayed as white,
even when the P-value is less than 1.

```{r, enrich-hm, fig.alt="Enrichment heatmap shown as a dotplot to indicate the number of genes involved."}
mem_enrichment_heatmap(mem_canonical,
   p_cutoff=0.05);
```

The same data can be plotted as a heatmap.

```{r, enrich-hm-1, fig.alt="Enrichment heatmap showing the heatmap style, without dot plot."}
mem_enrichment_heatmap(mem_canonical,
   style="heatmap",
   p_cutoff=0.05);
```


Argument `color_by_column=TRUE` applies the
color gradient to each column, using `colorV` colors defined
in from `multiEnrichMap()`.

```{r, enrich-hm-2, fig.alt="Enrichment heatmap, colorized by column, showing an alternative style."}
memhm <- mem_enrichment_heatmap(mem_canonical,
   style="heatmap",
   color_by_column=TRUE);
```


## Gene-Pathway Heatmap

We can view the pathway-gene matrix using the function

`mem_gene_path_heatmap()` produces a heatmap of the pathway-gene
incidence matrix. This heatmap is the core of multienrichjam.

It is also provided by:  
`mem_plot_folio(mem, do_which=2)`

The function will estimate the number of pathway clusters,
but can be customized:

* `column_split=3` will produce 3 pathway clusters.
* `row_split=10` will produce 10 gene clusters.

Colors across the top of the heatmap indicate
enrichment P-values.

Colors on the left of the heatmap indicate which genes were
present in each enrichment test.
When directional gene hits are provided, the left of the heatmap
will also indicate directionality.

```{r, mem-hm, fig.height=14, fig.width=10, fig.alt="Gene-pathway heatmap drawn specifically with mem_gene_path_heatmap()."}
hm <- mem_gene_path_heatmap(mem_canonical,
   column_cex=0.5,
   row_cex=0.6);
ComplexHeatmap::draw(hm,
   merge_legends=TRUE)
```

As a follow-up analysis, you can pull out each pathway
cluster from the heatmap itself, using `heatmap_column_order()`:

```{r, mem_hm_sets}
hm_sets <- heatmap_column_order(hm);
hm_sets;
```

## Full Cnet plot

The Concept network (Cnet) plot shows every pathway-gene relationship.

The helper function `memIM2cnet()` creates a Cnet plot
from the `mem_canonical` output.
Here, we also pipe the result through other helper functions:

* `fixSetLabels()` applies pathway label word wrap
* `relayout_with_qfr()` applies network layout and adjusts node labels
* `removeIgraphBlanks()` removes blank colors from the `igraph` nodes

```{r, cnet-plot-1, fig.height=10, fig.width=8, fig.alt="Full Cnet plot, for all pathways and genes."}
#cnet <- mem_canonical$multiCnetPlot1b;
cnet <- mem_canonical %>% 
   mem2cnet()
   # memIM2cnet() %>%
   # fixSetLabels() %>%
   # removeIgraphBlanks() %>%
   # relayout_with_qfr();

withr::with_par(list(mar=c(1, 1, 1, 1)+0.1), {
   jam_igraph(cnet,
      use_shadowText=TRUE,
      node_factor=0.5,
      vertex.label.cex=0.6);
   mem_legend(mem_canonical);
})
```

Extract the largest connected subnetwork.

```{r, cnet-plot-2, fig.height=10, fig.width=8, fig.alt="Cnet plot showing the largest connected sub-network."}
cnet_largest_sub <- subset_igraph_components(cnet, keep=1)

jam_igraph(cnet_largest_sub,
   use_shadowText=TRUE,
   label_factor=0.5,
   node_factor=0.5);
```

#### Subset Cnet by Cluster

Subset the pathway nodes with `subsetCnetIgraph()`,
using `hm_sets` defined above.

```{r, cnet-plot-1-custom, fig.height=10, fig.width=8, fig.alt="Cnet plot showing a specific Cnet cluster."}
cnet_sub <- subsetCnetIgraph(cnet,
   repulse=3.5,
   includeSets=unlist(hm_sets[c("A")]));
jam_igraph(cnet_sub,
   node_factor=1,
   use_shadowText=TRUE,
   label_dist_factor=3,
   label_factor=1.3);
mem_legend(mem_canonical);
```


#### Subset Cnet Options

Subset the pathway nodes with `subsetCnetIgraph()`,
using a custom subset of pathways.

Alternatively, subset by other network attributes:

* `minSetDegree=6`: pathways with at least 6 genes
* `minGeneDegree=2`: genes present in 2 or more pathways (not used here).

Other useful defaults:

* `remove_singlets=TRUE`: remove singlet nodes with no connections.
* `force_relayout=TRUE`: re-calculated the layout.
* `do_reorder=TRUE`: re-order nodes by color.
* `spread_labels=TRUE`: re-position labels away from incoming edges
* `remove_blanks=FALSE`: optionally remove blank colors from pie nodes.

```{r, subnet, fig.height=10, fig.width=8, fig.alt="Subset Cnet plot using a specific set of pathways."}
cnet3 <- multienrichjam::subsetCnetIgraph(cnet,
   repulse=5,
   minSetDegree=6,
   minGeneDegree=1);
jam_igraph(cnet3,
   node_factor=0.7,
   use_shadowText=TRUE);
mem_legend(mem_canonical);
```


## Multi-Enrichment Map

The "Multi Enrichment Map" itself can be view using
`mem2emap()`.

This network connects pathways when they meet a Jaccard
overlap coefficient threshold based upon the shared genes
between the pathways.

The default `0.2` is stored in the 'Mem' object `mem_canonical`.


```{r, mem-plot-1, fig.height=12, fig.width=10, fig.alt="Multi-enrichment network creating using mem2emap(), using the default overlap threshold 0.2."}
emap <- mem2emap(mem_canonical)

jam_igraph(emap,
   node_factor=2,
   use_shadowText=TRUE)
title(main="overlap=0.2")
```

You can provide the Jaccard overlap threshold directly,
with argument `overlap`. Values should be between 0 and 1.

A reasonable threshold can be estimated with
`mem_find_overlap()`, which determines an intermediate level
of connectivity, and should be a solid starting point for
future adjustments.

```{r, mem-plot-1b, fig.height=12, fig.width=10, fig.alt="Multi-enrichment network shown after using alternative overlap threshold."}
use_overlap <- mem_find_overlap(mem_canonical);

emap2 <- mem2emap(mem_canonical,
   overlap=use_overlap)

jam_igraph(emap2,
   node_factor=3,
   use_shadowText=TRUE)
title(main=paste0("overlap=", use_overlap))
```


Notice there are distinct subnetworks, called "components",
which are not connected to each other.

You can pull out a component with `subset_igraph_components()`.
Components are ordered by size, largest to smallest,
so you can keep the largest using argument `keep=1`,
or the second largest with `keep=2`, and so on.

We also call two other helper functions:

1. `removeIgraphBlanks()`

   * removes blank colors from multi-color
   nodes, such as pie nodes, or colored rectangle nodes.
   * It helps show only the remaining colors without the whitespace.

2. `relayout_with_qfr()`

   * Fruchterman-Reingold layout, with argument `repulse` used
   to adjust the spacing between nodes.
   * Also updates other useful attributes, and spreads the node labels
   to reduce label overlaps.

```{r, mem-plot-2, fig.alt="Network plot showing the largest connected sub-network of the multi-enrichment network."}
## You can alternatively pull out any other component
g_sub <- subset_igraph_components(emap2, keep=1);

## Re-apply network layout, and remove blank colors
g_sub <- relayout_with_qfr(repulse=3.5,
   removeIgraphBlanks(g_sub))

## Plot
jam_igraph(g_sub,
   node_factor=3,
   label_factor=2,
   use_shadowText=TRUE)
```


# jam_igraph() to plot igraph

`jam_igraph()` is a customized `igraph::plot()`, with benefits:

* `edge_bundling="connections"` (default) improves the rendering of edges
by bundling edges from node clusters, so they are drawn with
a bezier curve
* `use_shadowText=TRUE` (optional) will draw labels with a contrasting border
to improve legibility of text labels
* `rescale=FALSE` (default) keeps the network layout aspect ratio
instead of scaling the coordinates to fit the size.
of the plot window. It also properly scales the node and edge sizes.
* convenient resizing:

   * `label_factor`: adjusts `label.cex` by a multiplier
   * `node_factor`: adjusts `node.size` by a multiplier
   * `edge_factor`: adjusts `edge.width` by a multiplier
   * `label_dist_factor` re-scales the `label.dist` values by a multiplier

## Simple resizing

Consider the following changes, demonstrated below:

* `node_factor=2`: nodes 2x larger
* `edge_factor=2`: edges 2x wider
* `label_factor=1.2`: labels 20% larger
* `use_shadowText=TRUE`: shadow text labels
* `label_dist_factor=5`: label distance 5x farther from node center

```{r, jam-igraph-1, fig.height=10, fig.width=8, fig.alt="Network plot created using jam_igraph() as an enhanced alternative to the default igraph plot function."}
jam_igraph(cnet3,
   node_factor=2,
   edge_factor=2,
   label_factor=1.2, 
   label_dist_factor=5,
   use_shadowText=TRUE)
```

## Colored edges

Edges can be colorized using the colors of the connecting nodes,
a visual enhancement inspired by the Gephi network visualization tool.
This process is performed using `color_edges_by_nodes()`.

```{r, jam-igraph-2, fig.height=10, fig.width=8, fig.alt="Network plot is shown using edges colorized based upon the colors for the connected nodes."}
jam_igraph(color_edges_by_nodes(cnet3, alpha=0.7),
   edge_bundling="connections",
   # edge_factor=2,
   # node_factor=2,
   label_factor=1.2, 
   label_dist_factor=5,
   use_shadowText=TRUE)
```


# ShinyCat for Custom Cnet Layout

The R-shiny Cnet Adjustment Tool **ShinyCat** is intended to help polish
the Cnet plot layout when making a final figure.

The R-shiny app uses several functions:

* `nudge_igraph_node()`: mode individual nodes
* `adjust_cnet_nodeset()`: adjust spacing, position, rotation of a nodeset
* `reorder_igraph_nodes()`: sort nodes in a group by color
* `spread_igraph_labels()`: arrage labels radially away from incoming edges
* `bulk_cnet_adjustments()`: several operations applied in bulk

> Make sure to assign the output to a variable, or to click "Save RData"
from within the R-shiny app. For example:

```{r shinycat_1, eval=FALSE}
output_env <- launch_shinycat(g=cnet)
```

The output is stored in an `environment` called `output_env`.

```{r shinycat_2, eval=FALSE}
# obtain the output data
adj_cnet <- output_env$adj_cnet;
```

Then the new Cnet plot can be plotted, for example:

```{r shinycat_3, eval=FALSE}
# jam_graph
jam_igraph(adj_cnet,
   node_factor=2,
   use_shadowText=TRUE,
   label_factor_l=list(nodeType=c(Gene=2, Set=1)))
```

## ShinyCat Screenshot

An example of ShinyCat in action is shown below.

```{r shinycat-screen-2, echo=FALSE, out.width="100%", fig.alt="Screenshot of ShinyCat in action, with a Cnet network plot in the center, and several inputs on the left to adjust the layout."}
knitr::include_graphics("shinycat-2.png")
```

