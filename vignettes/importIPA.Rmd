---
title: "How to use Ingenuity IPA enrichment results"
name: importIPA
output:
  BiocStyle::html_document:
    df_print: kable
vignette: >
  %\VignetteIndexEntry{How to import and use Ingenuity IPA enrichment data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
# ragg_png <- function(..., res = 192) {
#   ragg::agg_png(..., res = res, units = "in")
# }

knitr::opts_chunk$set(
   collapse=TRUE,
   comment="#>",
   fig.height=12,
   fig.width=10,
   fig.align="center",
   dev="ragg_png"
)
```

```{r setup}
library(multienrichjam);
library(jamba);
library(colorjam);
suppressPackageStartupMessages(library(igraph));
suppressPackageStartupMessages(library(ComplexHeatmap));
options("stringsAsFactors"=FALSE, "warn"=-1);
```

# Import Ingenuity IPA data

This document describes steps recommended for using Ingenuity
Pathway Analysis (IPA) enrichment data.

Ingenuity IPA enrichment results should be exported from the IPA
app:

* Open an IPA pathway analysis result.
* Click `"Export All"` at the top-right of the menu bar.
* Choose either "Text .txt" or "Excel".

   * The Excel file must be`.xlsx` format.

* Save each enrichment result to a separate file.

This workflow demonstrates the import process using two
IPA enrichment files used by
[Reese et al 2019](https://doi.org/10.1016/j.jaci.2018.11.043)
https://doi.org/10.1016/j.jaci.2018.11.043
to compare enrichment results in newborns to older children.

## Import IPA data

To import an IPA text file, use `importIPAenrichment()`.
It works the same when importing Excel `.xlsx` format.

```{r, import_ipa_1}
newborn_txt <- system.file("extdata",
   "Newborns-IPA.txt",
   package="multienrichjam");
newborn_dfl <- importIPAenrichment(newborn_txt);
```

The result is a `list`, named by the IPA analysis.
Each element contains one `data.frame` with analysis results.
Shown below is a summary of results, with number of rows and columns,
created with `jamba::sdim()`.

```{r, ipa_1_sdim}
sdim(newborn_dfl);
```

In `multienrichjam`, you may want to analyze multiple IPA analyses.
The example below uses `lapply()` to import multiple IPA files.

```{r, import_ipa_1_2}
newborn_txt <- system.file("extdata",
   "Newborns-IPA.txt",
   package="multienrichjam");
olderchildren_txt <- system.file("extdata",
   "OlderChildren-IPA.txt",
   package="multienrichjam");

ipa_files <- c(Newborns=newborn_txt,
   OlderChildren=olderchildren_txt)

ipa_l <- lapply(ipa_files, importIPAenrichment);
```

A summary of the list of lists is shown below, using
`jamba::ssdim()`:

```{r, ipa_ssdim}
ssdim(ipa_l);
```


## Analyze IPA enrichments from one enrichment test

IPA performs multiple types of analyis, and we recommend using
one type for multienrichjam, starting with "Canonical Pathways".

Other data available for use:

* **"Canonical Pathways:**: IPA curated pathways (most common*).
* **"Upstream Regulators"**: IPA curated regulators that are predicted
to have 'upstream' effects in cell signaling.
* **"Diseases and Bio Functions"**: IPA curated disease-associated
pathways, which include category and sub-category annotations.
* **"Tox Functions"**: IPA curated toxicity-associated
pathways, which also include category and sub-category annotations.

**"Analysis Ready Molecules"**: is a `data.frame` that contains the
IPA gene cross-reference, which stores what *you* called a gene, and
what *IPA* recognized for their analysis.

* The default `revert_ipa_xref=TRUE` will convert IPA gene symbol to
*your* gene symbol as provided to IPA.
* If you provided microarray or platform identifiers, such as
Affymetrix `'1007_s_at'` or Agilent `'ID A_14_P109686'`, you may
try `revert_ipa_xref=FALSE`, which will retain the IPA gene symbol.

Extract 'Canonical Pathways' from each IPA result:

```{r, extract_canonical}
## Take only the Ingenuity Canonical Pathways
enrichList_canonical <- lapply(ipa_l, function(i){
   i[["Canonical Pathways"]];
});
sdim(enrichList_canonical);
```

### Convert to enrichResult (optional)

Each `data.frame` can be converted to `enrichResult`.
It is not strictly necessary, but may be useful to use with
functions related to `clusterProfiler`, for example `ggtangle::cnetplot()`.

This option may be useful to review the conversion.

```{r, extract_canonical_er}
## Convert data.frame to enrichResult
## multienrichjam::enrichDF2enrichResult
er_canonical <- lapply(enrichList_canonical, function(i){
   enrichDF2enrichResult(i,
      keyColname="Name",
      pvalueColname="P-value",
      geneColname="geneNames",
      geneRatioColname="Ratio",
      pvalueCutoff=1)
});
sdim(er_canonical);
kable_coloring(
   head(as.data.frame(er_canonical[[1]])),
   caption="Top 10 rows of enrichment data",
   row.names=FALSE) %>%
   kableExtra::column_spec(column=seq_len(ncol(er_canonical[[1]])),
      border_left="1px solid #DDDDDD",
      extra_css="white-space: nowrap;")

```

# multiEnrichMap() to create 'Mem'

Now given a list of `data.frame` results, we can
run `multiEnrichMap()`:

```{r, mem_canonical, fig.height=9, fig.width=10}
mem_canonical <- multiEnrichMap(er_canonical,
   enrichBaseline=1,
   p_cutoff=0.05,
   topEnrichN=10)
```

Output is a `list` containing summary results.

```{r, mem_sdim}
kable_coloring(
   sdim(mem_canonical),
   caption="sdim(mem_canonical)") %>%
   kableExtra::column_spec(column=seq_len(4),
      border_left="1px solid #DDDDDD",
      extra_css="white-space: nowrap;")
```


## prepare_folio() to create 'MemPlotFolio'

The next step is to prepare the "Mem Plot Folio", which performs
key pathway clustering to inform downstream visualizations.

* `prepare_folio()` prepares a 'MemPlotFolio' object
* `mem_plot_folio()` prepares *and plots* 'MemPlotFolio' as multi-page
output.

The plot data is created and stored in the 'MemPlotFolio' object,
and can be plotted directly using:

* `EnrichmentHeatmap()`: pathway by enrichment, showing enrichment P-values
* `GenePathHeatmap()`: genes by pathway, to define pathway clusters
* `CnetCollapsed()`: Concept network (Cnet) collapsed by pathway cluster
* `CnetExemplar()`: Cnet with one exemplar pathway per cluster
* `CnetCollapsed()`: Cnet showing all pathways in one cluster

The example below shows the first four plots from `mem_plot_folio()`:

```{r, mem-folio, fig.height=12, fig.width=8, fig.alt="Mem plot folio showing the first four plots"}
Mpf <- mem_plot_folio(mem_canonical,
   pathway_column_split=4,
   column_cex=0.4, row_cex=0.4,
   row_names_max_width=grid::unit(9, "cm"),
   column_names_max_height=grid::unit(4, "cm"),
   node_factor=2.5,
   label_factor_l=list(nodeType=c(Set=0.7, Gene=1.5)),
   use_shadowText=TRUE,
   do_which=c(1, 2, 3, 4),
   main="Canonical Pathways");
```

The object `Mpf` is a `'MemPlotFolio'` object containing
graphical objects. By default all plots in `do_which` are plotted,
however they can be plotted individually:

# Customizing Mem Plots

## Cnet Collapsed Plot

The Cnet Collapsed Plot is often the focus of manuscript figures.
The typical workflow is demonstrated below, using `CnetCollapsed()` on
the `MemPlotFolio` object.

Note that '...' extra arguments are passed to `jam_igraph()` for
custom plotting options.

```{r, cnet-collapsed, fig.height=12, fig.width=10, fig.alt="Cnet collapsed network extracted from mem_plot_folio() to use for custom figures."}
# generate the data
Mpf4 <- prepare_folio(mem_canonical,
   do_which=c(4))

# extract the cnet
cnet <- CnetCollapsed(Mpf4,
   type="set",
   node_factor=2,
   use_shadowText=TRUE,
   label_factor_l=list(nodeType=c(Gene=2, Set=1)))
   
## jam_graph()
# jam_igraph(cnet)
```


## Enrichment P-value Heatmap

The recommended way to create an enrichment heatmap is to use
`EnrichmentHeatmap(Mpf)` with the `'MemPlotFolio'` object.
Customization should be done via `mem_plot_folio()`,
for example changes to pathway clustering, and even custom font sizes.

Additional options for a enrichment heatmap are described in
the internal function `mem_enrichment_heatmap()`.

```{r, enrich-hm-mpf, fig.alt="Enrichment heatmap shown using the MemPlotFolio object as input."}
EnrichmentHeatmap(Mpf);
```

Note that the Mem object can be plotted directly as follows:

```{r, enrich-hm, fig.alt="Enrichment heatmap shown as a dotplot to indicate the number of genes involved."}
mem_enrichment_heatmap(mem_canonical,
   p_cutoff=0.05);
```

The same data can be plotted as a heatmap.

```{r, enrich-hm-1, fig.alt="Enrichment heatmap showing the heatmap style, without dot plot."}
mem_enrichment_heatmap(mem_canonical,
   style="heatmap",
   p_cutoff=0.05);
```

Argument `color_by_column=TRUE` applies the
color gradient to each column, using `colorV` colors defined
in from `multiEnrichMap()`.

```{r, enrich-hm-2, fig.alt="Enrichment heatmap, colorized by column, showing an alternative style."}
memhm <- mem_enrichment_heatmap(mem_canonical,
   style="heatmap",
   color_by_column=TRUE);
```

Any of these custom options can be passed to `mem_plot_folio()`,
so that the enrichment heatmap will follow that custom style.


## Gene-Pathway Heatmap

The gene-pathway heatmap is the critical step in downstream analysis,
and is visualized with `GenePathHeatmap(Mpf)` using the 'MemPlotFolio' object.

Additional options for the gene-pathway heatmap are described in
the internal function `mem_gene_path_heatmap()`.

* Colors across the top of the heatmap indicate
enrichment P-values.
* Colors on the left of the heatmap indicate which genes were
present in each enrichment test.
* When directional gene hits are provided, the left of the heatmap
will also indicate directionality.

```{r, mem-hm-mpf, fig.height=14, fig.width=10, fig.alt="Gene-pathway heatmap drawn specifically with mem_gene_path_heatmap()."}
hm_drawn <- GenePathHeatmap(Mpf);
```

You can pull out pathway clusters using `Clusters(Mpf)`, and
gene clusters using `GeneClusters(Mpf)`.

Alternatively, since `hm_drawn` is also a ComplexHeatmap object,
the row and column order can be interrogated using
`jamba::heatmap_column_order()` for example.

```{r, mem_hm_sets}
hm_sets <- heatmap_column_order(hm_drawn);
hm_sets;
```

## Full Cnet plot

The complete Concept network (Cnet) plot shows every pathway-gene
relationship, and is performed using `mem2cnet()`.

Note that the pathways can be subset using `[` bracket notation if relevant.

```{r, cnet-plot-1, fig.height=10, fig.width=8, fig.alt="Full Cnet plot, for all pathways and genes."}
cnet <- mem2cnet(mem_canonical)

withr::with_par(list(mar=c(1, 1, 1, 1)+0.1), {
   jam_igraph(cnet,
      use_shadowText=TRUE,
      node_factor=0.5,
      vertex.label.cex=0.6);
   mem_legend(mem_canonical);
})
```

Extract the largest connected subnetwork.

```{r, cnet-plot-2, fig.height=10, fig.width=8, fig.alt="Cnet plot showing the largest connected sub-network."}
cnet_largest_sub <- subset_igraph_components(cnet, keep=1)

jam_igraph(cnet_largest_sub,
   use_shadowText=TRUE,
   label_factor=0.5,
   node_factor=0.5);
```

#### Subset Cnet by Cluster

Subset the pathway nodes with `subsetCnetIgraph()`,
using `hm_sets` defined above.

```{r, cnet-plot-1-custom, fig.height=10, fig.width=8, fig.alt="Cnet plot showing a specific Cnet cluster."}
cnet_sub <- subsetCnetIgraph(cnet,
   repulse=3.5,
   includeSets=unlist(hm_sets[c("A")]));
jam_igraph(cnet_sub,
   node_factor=1,
   use_shadowText=TRUE,
   label_dist_factor=3,
   label_factor=1.3);
mem_legend(mem_canonical);
```


#### Subset Cnet Options

Subset the pathway nodes with `subsetCnetIgraph()`,
using a custom subset of pathways.

Alternatively, subset by other network attributes:

* `minSetDegree=6`: pathways with at least 6 genes
* `minGeneDegree=2`: genes present in 2 or more pathways (not used here).

Other useful defaults:

* `remove_singlets=TRUE`: remove singlet nodes with no connections.
* `force_relayout=TRUE`: re-calculated the layout.
* `do_reorder=TRUE`: re-order nodes by color.
* `spread_labels=TRUE`: re-position labels away from incoming edges
* `remove_blanks=FALSE`: optionally remove blank colors from pie nodes.

```{r, subnet, fig.height=10, fig.width=8, fig.alt="Subset Cnet plot using a specific set of pathways."}
cnet3 <- multienrichjam::subsetCnetIgraph(cnet,
   repulse=5,
   minSetDegree=6,
   minGeneDegree=1);
jam_igraph(cnet3,
   node_factor=0.7,
   use_shadowText=TRUE);
mem_legend(mem_canonical);
```


## Multi-Enrichment Map

The "Multi Enrichment Map" itself can be view using
`mem2emap()`.

This network connects pathways when they meet a Jaccard
overlap coefficient threshold based upon the shared genes
between the pathways.

The default `0.2` is stored in the 'Mem' object `mem_canonical`.


```{r, mem-plot-1, fig.height=12, fig.width=10, fig.alt="Multi-enrichment network creating using mem2emap(), using the default overlap threshold 0.2."}
emap <- mem2emap(mem_canonical)

jam_igraph(emap,
   node_factor=2,
   use_shadowText=TRUE)
title(main="overlap=0.2")
```

You can provide the Jaccard overlap threshold directly,
with argument `overlap`. Values should be between 0 and 1.

A reasonable threshold can be estimated with
`mem_find_overlap()`, which determines an intermediate level
of connectivity, and should be a solid starting point for
future adjustments.

```{r, mem-plot-1b, fig.height=12, fig.width=10, fig.alt="Multi-enrichment network shown after using alternative overlap threshold."}
use_overlap <- mem_find_overlap(mem_canonical);

emap2 <- mem2emap(mem_canonical,
   overlap=use_overlap)

jam_igraph(emap2,
   node_factor=3,
   use_shadowText=TRUE)
title(main=paste0("overlap=", use_overlap))
```


Notice there are distinct subnetworks, called "components",
which are not connected to each other.

You can pull out a component with `subset_igraph_components()`.
Components are ordered by size, largest to smallest,
so you can keep the largest using argument `keep=1`,
or the second largest with `keep=2`, and so on.

We also call two other helper functions:

1. `removeIgraphBlanks()`

   * removes blank colors from multi-color
   nodes, such as pie nodes, or colored rectangle nodes.
   * It helps show only the remaining colors without the whitespace.

2. `relayout_with_qfr()`

   * Fruchterman-Reingold layout, with argument `repulse` used
   to adjust the spacing between nodes.
   * Also updates other useful attributes, and spreads the node labels
   to reduce label overlaps.

```{r, mem-plot-2, fig.alt="Network plot showing the largest connected sub-network of the multi-enrichment network."}
## You can alternatively pull out any other component
g_sub <- subset_igraph_components(emap2, keep=1);

## Re-apply network layout, and remove blank colors
g_sub <- relayout_with_qfr(repulse=3.5,
   removeIgraphBlanks(g_sub))

## Plot
jam_igraph(g_sub,
   node_factor=3,
   label_factor=2,
   use_shadowText=TRUE)
```


# jam_igraph() to plot igraph

`jam_igraph()` is a customized `igraph::plot()`, with benefits:

* `edge_bundling="connections"` (default) improves the rendering of edges
by bundling edges from node clusters, so they are drawn with
a bezier curve
* `use_shadowText=TRUE` (optional) will draw labels with a contrasting border
to improve legibility of text labels
* `rescale=FALSE` (default) keeps the network layout aspect ratio
instead of scaling the coordinates to fit the size.
of the plot window. It also properly scales the node and edge sizes.
* convenient resizing:

   * `label_factor`: adjusts `label.cex` by a multiplier
   * `node_factor`: adjusts `node.size` by a multiplier
   * `edge_factor`: adjusts `edge.width` by a multiplier
   * `label_dist_factor` re-scales the `label.dist` values by a multiplier

## Simple resizing

Consider the following changes, demonstrated below:

* `node_factor=2`: nodes 2x larger
* `edge_factor=2`: edges 2x wider
* `label_factor=1.2`: labels 20% larger
* `use_shadowText=TRUE`: shadow text labels
* `label_dist_factor=5`: label distance 5x farther from node center

```{r, jam-igraph-1, fig.height=10, fig.width=8, fig.alt="Network plot created using jam_igraph() as an enhanced alternative to the default igraph plot function."}
jam_igraph(cnet3,
   node_factor=2,
   edge_factor=2,
   label_factor=1.2, 
   label_dist_factor=5,
   use_shadowText=TRUE)
```

## Colored edges

Edges can be colorized using the colors of the connecting nodes,
a visual enhancement inspired by the Gephi network visualization tool.
This process is performed using `color_edges_by_nodes()`.

```{r, jam-igraph-2, fig.height=10, fig.width=8, fig.alt="Network plot is shown using edges colorized based upon the colors for the connected nodes."}
jam_igraph(color_edges_by_nodes(cnet3, alpha=0.7),
   edge_bundling="connections",
   # edge_factor=2,
   # node_factor=2,
   label_factor=1.2, 
   label_dist_factor=5,
   use_shadowText=TRUE)
```


# ShinyCat for Custom Cnet Layout

The R-shiny Cnet Adjustment Tool **ShinyCat** is intended to help polish
the Cnet plot layout when making a final figure.

The R-shiny app uses several functions:

* `nudge_igraph_node()`: mode individual nodes
* `adjust_cnet_nodeset()`: adjust spacing, position, rotation of a nodeset
* `reorder_igraph_nodes()`: sort nodes in a group by color
* `spread_igraph_labels()`: arrage labels radially away from incoming edges
* `bulk_cnet_adjustments()`: several operations applied in bulk

> Make sure to assign the output to a variable, or to click "Save RData"
from within the R-shiny app. For example:

```{r shinycat_1, eval=FALSE}
output_env <- launch_shinycat(g=cnet)
```

The output is stored in an `environment` called `output_env`.

```{r shinycat_2, eval=FALSE}
# obtain the output data
adj_cnet <- output_env$adj_cnet;
```

Then the new Cnet plot can be plotted, for example:

```{r shinycat_3, eval=FALSE}
# jam_graph
jam_igraph(adj_cnet,
   node_factor=2,
   use_shadowText=TRUE,
   label_factor_l=list(nodeType=c(Gene=2, Set=1)))
```

## ShinyCat Screenshot

An example of ShinyCat in action is shown below.

```{r shinycat-screen-2, echo=FALSE, out.width="100%", fig.alt="Screenshot of ShinyCat in action, with a Cnet network plot in the center, and several inputs on the left to adjust the layout."}
knitr::include_graphics("shinycat-2.png")
```

